{"ast":null,"code":"import { _ as _class_call_check } from \"@swc/helpers/_/_class_call_check\";\nimport { _ as _create_class } from \"@swc/helpers/_/_create_class\";\nimport { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { BrowserSymbol } from \"./browser-symbol\";\nvar namespaceURI = \"http://www.w3.org/2000/svg\";\nexport var BrowserSprite = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function BrowserSprite() {\n    var config = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n\n    _class_call_check(this, BrowserSprite);\n\n    _define_property(this, \"symbols\", new Map());\n\n    _define_property(this, \"config\", {\n      attrs: {\n        \"xmlns\": namespaceURI,\n        \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\",\n        \"style\": \"position:absolute;width:0;height:0\",\n        \"aria-hidden\": \"true\"\n      }\n    });\n\n    _define_property(this, \"node\", null);\n\n    Object.assign(this.config.attrs, config.attrs);\n  }\n\n  _create_class(BrowserSprite, [{\n    key: \"push\",\n    value: function push(symbol) {\n      var symbols = this.symbols;\n      var existing = symbols.has(symbol.id);\n      symbols.set(symbol.id, symbol);\n      return !existing;\n    }\n  }, {\n    key: \"add\",\n    value: function add(symbol) {\n      var isNewSymbol = this.push(symbol);\n\n      if (!!this.node && isNewSymbol) {\n        symbol.mount(this.node);\n      }\n\n      return isNewSymbol;\n    }\n  }, {\n    key: \"attach\",\n    value: function attach(target) {\n      var _this = this;\n\n      if (!!this.node) {\n        return;\n      }\n\n      this.node = target; // Already added symbols needs to be mounted\n\n      this.symbols.forEach(function (symbol) {\n        symbol.mount(target);\n      }); // Create symbols from existing DOM nodes, add and mount them\n\n      target.querySelectorAll(\"symbol\").forEach(function (symbolNode) {\n        var symbol = BrowserSymbol.createFromExistingNode(symbolNode);\n\n        _this.add(symbol);\n      });\n    }\n  }, {\n    key: \"mount\",\n    value: function mount(target) {\n      var prepend = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n\n      if (!!this.node) {\n        return this.node;\n      }\n\n      this.node = this.render();\n\n      if (prepend && target.childNodes[0]) {\n        target.insertBefore(this.node, target.firstChild);\n      } else {\n        target.appendChild(this.node);\n      }\n\n      return this.node;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var el = document.createElementNS(namespaceURI, \"svg\");\n      Object.entries(this.config.attrs).forEach(function (entry) {\n        return el.setAttribute(entry[0], entry[1]);\n      });\n      this.symbols.forEach(function (symbol) {\n        return el.appendChild(symbol.node);\n      });\n      return el;\n    }\n  }, {\n    key: \"unmount\",\n    value: function unmount() {\n      this.node && this.node.parentNode && this.node.parentNode.removeChild(this.node);\n    }\n  }]);\n\n  return BrowserSprite;\n}();","map":{"version":3,"mappings":";;;AAAA,SAASA,aAAT,QAA8B,kBAA9B;AAEA,IAAMC,eAAe,4BAArB;AAMA,OAAO,iBAAMC,gBAAN;;;WAAMA;QAaCC,0EAAuB;;4BAbxBD;;IACXE,uBAAQC,SAAR,EAA8C,IAAIC,GAAJ,EAA9C;;IACAF,uBAAQD,QAAR,EAA+B;MAC7BI,OAAO;QACL,SAASN,YADJ;QAEL,eAAe,8BAFV;QAGL,SAAS,oCAHJ;QAIL,eAAe;MAJV;IADsB,CAA/B;;IASAO,+BAAuB,IAAvBA;;IAGEC,OAAOC,MAAPD,CAAc,KAAKN,MAAL,CAAYI,KAA1BE,EAAkCN,OAAOI,KAAzCE;;;gBAdSP;IAiBHS;WAAR,SAAQA,IAAR,CAAaC,MAAb,EAAkC;MAChC,IAAMP,OAAEA,GAAY,KAAZA,OAAR;MACA,IAAMQ,WAAWR,QAAQS,GAART,CAAYO,OAAOG,EAAnBV,CAAjB;MAEAA,QAAQW,GAARX,CAAYO,OAAOG,EAAnBV,EAAuBO,MAAvBP;MAEA,OAAO,CAACQ,QAAR;IACF;GAxBWX;IA0BXe;WAAAA,aAAIL,MAAJK,EAAyB;MACvB,IAAMC,cAAc,KAAKP,IAAL,CAAUC,MAAV,CAApB;;MAEA,IAAI,CAAC,CAAC,KAAKJ,IAAP,IAAeU,WAAnB,EAAgC;QAC9BN,OAAOO,KAAPP,CAAa,KAAKJ,IAAlBI;MACF;;MAEA,OAAOM,WAAP;IACF;GAlCWhB;IAoCXkB;WAAAA,gBAAOC,MAAPD,EAAsB;;;MACpB,IAAI,CAAC,CAAC,KAAKZ,IAAX,EAAiB;QACf;MACF;;MAEA,KAAKA,IAAL,GAAYa,MAAZ,CALoB,CAOpB;;MACA,KAAKhB,OAAL,CAAaiB,OAAb,CAAqB,UAACV,MAAD,EAACA;QACpBA,OAAOO,KAAPP,CAAaS,MAAbT;MACF,CAFA,EARoB,CAYpB;;MACAS,OAAOE,gBAAPF,CAAwB,QAAxBA,EAAkCC,OAAlCD,CAA0C,UAACG,UAAD,EAACA;QACzC,IAAMZ,SAASZ,cAAcyB,sBAAdzB,CAAqCwB,UAArCxB,CAAf;;QACA0B,MAAKT,GAAL,CAASL,MAAT;MACF,CAHAS;IAIF;GArDWnB;IAuDXiB;WAAAA,eAAME,MAANF,EAAkB;UAAEQ,2EAAU;;MAC5B,IAAI,CAAC,CAAC,KAAKnB,IAAX,EAAiB;QACf,OAAO,KAAKA,IAAZ;MACF;;MAEA,KAAKA,IAAL,GAAY,KAAKoB,MAAL,EAAZ;;MAEA,IAAID,WAAWN,OAAOQ,UAAPR,CAAkB,CAAlBA,CAAf,EAAqC;QACnCA,OAAOS,YAAPT,CAAoB,KAAKb,IAAzBa,EAA+BA,OAAOU,UAAtCV;MACF,CAFA,MAEO;QACLA,OAAOW,WAAPX,CAAmB,KAAKb,IAAxBa;MACF;;MAEA,OAAO,KAAKb,IAAZ;IACF;GArEWN;IAuEH0B;WAAR,SAAQA,MAAR,GAAQA;MACN,IAAMK,KAAKC,SAASC,eAATD,CAAyBjC,YAAzBiC,EAAuC,KAAvCA,CAAX;MAEAzB,OAAO2B,OAAP3B,CAAe,KAAKN,MAAL,CAAYI,KAA3BE,EAAmCa,OAAnCb,CAA2C,UAAC4B,KAAD,EAACA;eAAUJ,GAAGK,YAAHL,CAAgBI,KAAK,CAAC,CAAD,CAArBJ,EAA0BI,KAAK,CAAC,CAAD,CAA/BJ;OAAtDxB;MACA,KAAKJ,OAAL,CAAaiB,OAAb,CAAqB,UAACV,MAAD,EAACA;eAAWqB,GAAGD,WAAHC,CAAerB,OAAOJ,IAAtByB;OAAjC;MAEA,OAAOA,EAAP;IACF;GA9EW/B;IAgFXqC;WAAAA;MACE,KAAK/B,IAAL,IAAa,KAAKA,IAAL,CAAUgC,UAAvB,IAAqC,KAAKhC,IAAL,CAAUgC,UAAV,CAAqBC,WAArB,CAAiC,KAAKjC,IAAtC,CAArC;IACF;GAlFWN;;SAAAA;CAAN","names":["BrowserSymbol","namespaceURI","BrowserSprite","config","_define_property","symbols","Map","attrs","node","Object","assign","push","symbol","existing","has","id","set","add","isNewSymbol","mount","attach","target","forEach","querySelectorAll","symbolNode","createFromExistingNode","_this","prepend","render","childNodes","insertBefore","firstChild","appendChild","el","document","createElementNS","entries","entry","setAttribute","unmount","parentNode","removeChild"],"sources":["C:\\Users\\kulag\\vk\\Ability\\node_modules\\@vkontakte\\icons-sprite\\src\\browser-sprite.ts"],"sourcesContent":["import { BrowserSymbol } from './browser-symbol';\n\nconst namespaceURI = 'http://www.w3.org/2000/svg';\n\nexport interface SpriteConfig {\n  attrs?: Record<string, string>;\n}\n\nexport class BrowserSprite {\n  private symbols: Map<string, BrowserSymbol> = new Map();\n  private config: SpriteConfig = {\n    attrs: {\n      'xmlns': namespaceURI,\n      'xmlns:xlink': 'http://www.w3.org/1999/xlink',\n      'style': 'position:absolute;width:0;height:0',\n      'aria-hidden': 'true',\n    },\n  };\n\n  node: Element | null = null;\n\n  constructor(config: SpriteConfig = {}) {\n    Object.assign(this.config.attrs!, config.attrs);\n  }\n\n  private push(symbol: BrowserSymbol) {\n    const { symbols } = this;\n    const existing = symbols.has(symbol.id);\n\n    symbols.set(symbol.id, symbol);\n\n    return !existing;\n  }\n\n  add(symbol: BrowserSymbol) {\n    const isNewSymbol = this.push(symbol);\n\n    if (!!this.node && isNewSymbol) {\n      symbol.mount(this.node);\n    }\n\n    return isNewSymbol;\n  }\n\n  attach(target: Element) {\n    if (!!this.node) {\n      return;\n    }\n\n    this.node = target;\n\n    // Already added symbols needs to be mounted\n    this.symbols.forEach((symbol) => {\n      symbol.mount(target);\n    });\n\n    // Create symbols from existing DOM nodes, add and mount them\n    target.querySelectorAll('symbol').forEach((symbolNode: Element) => {\n      const symbol = BrowserSymbol.createFromExistingNode(symbolNode);\n      this.add(symbol);\n    });\n  }\n\n  mount(target: Node, prepend = false) {\n    if (!!this.node) {\n      return this.node;\n    }\n\n    this.node = this.render();\n\n    if (prepend && target.childNodes[0]) {\n      target.insertBefore(this.node, target.firstChild);\n    } else {\n      target.appendChild(this.node);\n    }\n\n    return this.node;\n  }\n\n  private render() {\n    const el = document.createElementNS(namespaceURI, 'svg');\n\n    Object.entries(this.config.attrs!).forEach((entry) => el.setAttribute(entry[0], entry[1]));\n    this.symbols.forEach((symbol) => el.appendChild(symbol.node));\n\n    return el;\n  }\n\n  unmount() {\n    this.node && this.node.parentNode && this.node.parentNode.removeChild(this.node);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}