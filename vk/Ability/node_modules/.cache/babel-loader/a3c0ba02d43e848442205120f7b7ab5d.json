{"ast":null,"code":"import { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\nimport * as React from \"react\";\nimport { clamp } from \"../helpers/math\";\nimport { rangeIncrement } from \"../helpers/range\";\n/**\n * Хук позаимствован у @mui с некоторыми изменениями.\n *  [usePagination.js](https://github.com/mui/material-ui/blob/master/packages/mui-material/src/usePagination/usePagination.js).\n *\n * Примеры вывода:\n *           v\n * [1, 2, 3, 4, 5, 'end-ellipsis', 10]\n *                          v\n * [1, 'start-ellipsis', 4, 5, 6, 'end-ellipsis', 10]\n *                          v\n * [1, 'start-ellipsis', 6, 7, 8, 9, 10]\n */\n\nexport var usePagination = function () {\n  var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {},\n      _ref_currentPage = _ref.currentPage,\n      currentPage = _ref_currentPage === void 0 ? 1 : _ref_currentPage,\n      _ref_siblingCount = _ref.siblingCount,\n      siblingCount = _ref_siblingCount === void 0 ? 1 : _ref_siblingCount,\n      _ref_boundaryCount = _ref.boundaryCount,\n      boundaryCount = _ref_boundaryCount === void 0 ? 1 : _ref_boundaryCount,\n      tmp = _ref.totalPages,\n      endPage = tmp === void 0 ? 1 : tmp;\n\n  return React.useMemo(function () {\n    var _pages, _pages1;\n\n    var startPages = rangeIncrement(1, Math.min(boundaryCount, endPage));\n    var endPages = rangeIncrement(Math.max(endPage - boundaryCount + 1, boundaryCount + 1), endPage);\n    var lowerBoundaryWhenCurrentPageHigh = endPage - boundaryCount - 1 - 2 * siblingCount;\n    var siblingsStart = clamp(currentPage - siblingCount, boundaryCount + 2, lowerBoundaryWhenCurrentPageHigh);\n    var upperBoundaryWhenCurrentPageLow = boundaryCount + 2 + 2 * siblingCount;\n    var siblingsEnd = Math.min(Math.max(currentPage + siblingCount, upperBoundaryWhenCurrentPageLow), endPages.length > 0 ? endPages[0] - 2 : endPage - 1);\n    var pages = startPages;\n\n    if (siblingsStart > boundaryCount + 2) {\n      pages.push(\"start-ellipsis\");\n    } else if (boundaryCount + 1 < endPage - boundaryCount) {\n      pages.push(boundaryCount + 1);\n    }\n\n    (_pages = pages).push.apply(_pages, _to_consumable_array(rangeIncrement(siblingsStart, siblingsEnd)));\n\n    if (siblingsEnd < endPage - boundaryCount - 1) {\n      pages.push(\"end-ellipsis\");\n    } else if (endPage - boundaryCount > boundaryCount) {\n      pages.push(endPage - boundaryCount);\n    }\n\n    (_pages1 = pages).push.apply(_pages1, _to_consumable_array(endPages));\n\n    return pages;\n  }, [currentPage, endPage, siblingCount, boundaryCount]);\n};","map":{"version":3,"mappings":";AAAA,YAAYA,KAAZ,MAAuB,OAAvB;AACA,SAASC,KAAT,QAAsB,iBAAtB;AACA,SAASC,cAAT,QAA+B,kBAA/B;AAyBA;;;;;;;;;;;;;AAYA,OAAO,IAAMC,gBAAgB;8EAKL;MAACC,wBAJvBC;MAAAA,4CAAc,CAAdA,GAAcD;MAAAE,yBACdC;MAAAA,8CAAe,CAAfA,GAAeD;MAAAE,0BACfC;MAAAA,gDAAgB,CAAhBA,GAAgBD;MACJE,WAAZC;MAAYD,2BAAU,CAAVA;;SAEZV,MAAMY,OAANZ,CAAc;QA4BZa,QAQAA;;IAnCA,IAAMC,aAAaZ,eAAe,CAAfA,EAAkBa,KAAKC,GAALD,CAASN,aAATM,EAAwBL,OAAxBK,CAAlBb,CAAnB;IACA,IAAMe,WAAWf,eACfa,KAAKG,GAALH,CAASL,UAAUD,aAAVC,GAA0B,CAAnCK,EAAsCN,gBAAgB,CAAtDM,CADeb,EAEfQ,OAFeR,CAAjB;IAKA,IAAMiB,mCAAmCT,UAAUD,aAAVC,GAA0B,CAA1BA,GAA8B,IAAIH,YAA3E;IACA,IAAMa,gBAAgBnB,MACpBI,cAAcE,YADMN,EAEpBQ,gBAAgB,CAFIR,EAGpBkB,gCAHoBlB,CAAtB;IAMA,IAAMoB,kCAAkCZ,gBAAgB,CAAhBA,GAAoB,IAAIF,YAAhE;IACA,IAAMe,cAAcP,KAAKC,GAALD,CAClBA,KAAKG,GAALH,CAASV,cAAcE,YAAvBQ,EAAqCM,+BAArCN,CADkBA,EAElBE,SAASM,MAATN,GAAkB,CAAlBA,GAAsBA,QAAQ,CAAC,CAAD,CAARA,GAAc,CAApCA,GAAwCP,UAAU,CAFhCK,CAApB;IAKA,IAAMF,QAA6BC,UAAnC;;IAEA,IAAIM,gBAAgBX,gBAAgB,CAApC,EAAuC;MACrCI,MAAMW,IAANX,CAAW,gBAAXA;IACF,CAFA,MAEO,IAAIJ,gBAAgB,CAAhBA,GAAoBC,UAAUD,aAAlC,EAAiD;MACtDI,MAAMW,IAANX,CAAWJ,gBAAgB,CAA3BI;IACF;;IAEAA,iBAAMW,IAANX,eAAWY,qBAAGvB,eAAekB,aAAflB,EAA8BoB,WAA9BpB,CAAH,CAAXW;;IAEA,IAAIS,cAAcZ,UAAUD,aAAVC,GAA0B,CAA5C,EAA+C;MAC7CG,MAAMW,IAANX,CAAW,cAAXA;IACF,CAFA,MAEO,IAAIH,UAAUD,aAAVC,GAA0BD,aAA9B,EAA6C;MAClDI,MAAMW,IAANX,CAAWH,UAAUD,aAArBI;IACF;;IAEAA,kBAAMW,IAANX,gBAAWY,qBAAGR,QAAH,CAAXJ;;IAEA,OAAOA,KAAP;EACF,CAvCAb,EAuCG,CAACK,WAAD,EAAcK,OAAd,EAAuBH,YAAvB,EAAqCE,aAArC,CAvCHT;CANK","names":["React","clamp","rangeIncrement","usePagination","_ref_currentPage","currentPage","_ref_siblingCount","siblingCount","_ref_boundaryCount","boundaryCount","endPage","totalPages","useMemo","pages","startPages","Math","min","endPages","max","lowerBoundaryWhenCurrentPageHigh","siblingsStart","upperBoundaryWhenCurrentPageLow","siblingsEnd","length","push","_to_consumable_array"],"sources":["C:\\Users\\kulag\\vk\\Ability\\node_modules\\@vkontakte\\vkui\\src\\hooks\\usePagination.ts"],"sourcesContent":["import * as React from 'react';\nimport { clamp } from '../helpers/math';\nimport { rangeIncrement } from '../helpers/range';\n\ninterface UsePaginationProps {\n  /**\n   * Текущая страница.\n   */\n  currentPage?: number;\n  /**\n   * Кол-во всегда видимых страниц по краям текущей страницы.\n   */\n  siblingCount?: number;\n  /**\n   * Кол-во всегда видимых страниц в начале и в конце.\n   */\n  boundaryCount?: number;\n  /**\n   * Общее кол-во страниц.\n   */\n  totalPages?: number;\n}\n\nexport type PaginationPageType = 'start-ellipsis' | 'end-ellipsis' | number;\n\nexport type UsePaginationResult = PaginationPageType[];\n\n/**\n * Хук позаимствован у @mui с некоторыми изменениями.\n *  [usePagination.js](https://github.com/mui/material-ui/blob/master/packages/mui-material/src/usePagination/usePagination.js).\n *\n * Примеры вывода:\n *           v\n * [1, 2, 3, 4, 5, 'end-ellipsis', 10]\n *                          v\n * [1, 'start-ellipsis', 4, 5, 6, 'end-ellipsis', 10]\n *                          v\n * [1, 'start-ellipsis', 6, 7, 8, 9, 10]\n */\nexport const usePagination = ({\n  currentPage = 1,\n  siblingCount = 1,\n  boundaryCount = 1,\n  totalPages: endPage = 1,\n}: UsePaginationProps = {}): UsePaginationResult =>\n  React.useMemo(() => {\n    const startPages = rangeIncrement(1, Math.min(boundaryCount, endPage));\n    const endPages = rangeIncrement(\n      Math.max(endPage - boundaryCount + 1, boundaryCount + 1),\n      endPage,\n    );\n\n    const lowerBoundaryWhenCurrentPageHigh = endPage - boundaryCount - 1 - 2 * siblingCount;\n    const siblingsStart = clamp(\n      currentPage - siblingCount,\n      boundaryCount + 2,\n      lowerBoundaryWhenCurrentPageHigh,\n    );\n\n    const upperBoundaryWhenCurrentPageLow = boundaryCount + 2 + 2 * siblingCount;\n    const siblingsEnd = Math.min(\n      Math.max(currentPage + siblingCount, upperBoundaryWhenCurrentPageLow),\n      endPages.length > 0 ? endPages[0] - 2 : endPage - 1,\n    );\n\n    const pages: UsePaginationResult = startPages;\n\n    if (siblingsStart > boundaryCount + 2) {\n      pages.push('start-ellipsis');\n    } else if (boundaryCount + 1 < endPage - boundaryCount) {\n      pages.push(boundaryCount + 1);\n    }\n\n    pages.push(...rangeIncrement(siblingsStart, siblingsEnd));\n\n    if (siblingsEnd < endPage - boundaryCount - 1) {\n      pages.push('end-ellipsis');\n    } else if (endPage - boundaryCount > boundaryCount) {\n      pages.push(endPage - boundaryCount);\n    }\n\n    pages.push(...endPages);\n\n    return pages;\n  }, [currentPage, endPage, siblingCount, boundaryCount]);\n"]},"metadata":{},"sourceType":"module"}