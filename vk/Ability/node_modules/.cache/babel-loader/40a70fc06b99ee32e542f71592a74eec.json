{"ast":null,"code":"import { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _sliced_to_array } from \"@swc/helpers/_/_sliced_to_array\";\nimport * as React from \"react\";\nimport { classNames } from \"@vkontakte/vkjs\";\nimport { clamp } from \"../../helpers/math\";\nimport { useAdaptivity } from \"../../hooks/useAdaptivity\";\nimport { useExternRef } from \"../../hooks/useExternRef\";\nimport { SizeType } from \"../../lib/adaptivity\";\nimport { Touch } from \"../Touch/Touch\";\nimport { SliderThumb } from \"./SliderThumb/SliderThumb\";\nimport { extractSliderAriaAttributesFromRestProps, getDraggingTypeByTargetDataset, isMultipleValues, offsetToValue, snapDirection, toPercent, updateInternalStateValue, updateInternalStateValueByNativeChange } from \"./helpers\";\n\nvar sizeYClassNames = _define_property({\n  none: \"vkuiSlider--sizeY-none\"\n}, SizeType.COMPACT, \"vkuiSlider--sizeY-compact\");\n/**\n * @see https://vkcom.github.io/VKUI/#/Slider\n */\n\n\nexport var Slider = function (_param) {\n  var // TODO [>=6]: Выставить 1 как значение по умолчанию, чтобы было как в браузерном <input type=\"range\" />\n  step = _param.step,\n      _param_min = _param.min,\n      min = _param_min === void 0 ? 0 : _param_min,\n      _param_max = _param.max,\n      max = _param_max === void 0 ? 100 : _param_max,\n      valueProp = _param.value,\n      multipleProp = _param.multiple,\n      _param_defaultValue = _param.defaultValue,\n      defaultValue = _param_defaultValue === void 0 ? multipleProp ? [min, max] : min : _param_defaultValue,\n      disabled = _param.disabled,\n      className = _param.className,\n      getRootRef = _param.getRootRef,\n      getAriaLabel = _param.getAriaLabel,\n      getAriaValueText = _param.getAriaValueText,\n      onChange = _param.onChange,\n      withTooltip = _param.withTooltip,\n      restProps = _object_without_properties(_param, [\"step\", \"min\", \"max\", \"value\", \"multiple\", \"defaultValue\", \"disabled\", \"className\", \"getRootRef\", \"getAriaLabel\", \"getAriaValueText\", \"onChange\", \"withTooltip\"]);\n\n  var _useAdaptivity = useAdaptivity(),\n      _useAdaptivity_sizeY = _useAdaptivity.sizeY,\n      sizeY = _useAdaptivity_sizeY === void 0 ? \"none\" : _useAdaptivity_sizeY;\n\n  var isControlled = valueProp !== undefined;\n\n  var _React_useState = _sliced_to_array(React.useState(defaultValue), 2),\n      localValue = _React_useState[0],\n      setValue = _React_useState[1];\n\n  var value = React.useMemo(function () {\n    var resolvedValue = isControlled ? valueProp : localValue;\n    return Array.isArray(resolvedValue) ? [clamp(resolvedValue[0], min, max), clamp(resolvedValue[1], min, max)] : [clamp(resolvedValue, min, max), null];\n  }, [isControlled, valueProp, localValue, min, max]);\n\n  var _value = _sliced_to_array(value, 2),\n      startValue = _value[0],\n      endValue = _value[1];\n\n  var multiple = multipleProp && endValue !== null;\n  var startValueInPercent = toPercent(startValue, min, max);\n  var endReversedValueInPercent = multiple ? toPercent(endValue, min, max) : 0;\n  var gesture = React.useRef({\n    dragging: null,\n    startX: 0,\n    containerWidth: 0\n  }).current;\n  var thumbsContainerRef = useExternRef(getRootRef);\n  var thumbStartInputRef = React.useRef(null);\n  var thumbEndInputRef = React.useRef(null);\n\n  var _extractSliderAriaAttributesFromRestProps = extractSliderAriaAttributesFromRestProps(restProps),\n      ariaLabel = _extractSliderAriaAttributesFromRestProps.ariaLabel,\n      ariaValueText = _extractSliderAriaAttributesFromRestProps.ariaValueText,\n      ariaLabelledBy = _extractSliderAriaAttributesFromRestProps.ariaLabelledBy,\n      restPropsWithoutAriaAttributes = _object_without_properties(_extractSliderAriaAttributesFromRestProps, [\"ariaLabel\", \"ariaValueText\", \"ariaLabelledBy\"]);\n\n  var changeValue = function (nextValue, event) {\n    if (disabled || value[0] === nextValue[0] && value[1] === nextValue[1]) {\n      return;\n    }\n\n    if (multipleProp) {\n      if (isMultipleValues(nextValue)) {\n        !isControlled && setValue(nextValue);\n        onChange && onChange(nextValue, event);\n      }\n    } else {\n      !isControlled && setValue(nextValue[0]);\n      onChange && onChange(nextValue[0], event);\n    }\n  };\n\n  var handlePointerStart = function (event) {\n    if (!thumbsContainerRef.current) {\n      return;\n    }\n\n    var _thumbsContainerRef_current_getBoundingClientRect = thumbsContainerRef.current.getBoundingClientRect(),\n        nextContainerX = _thumbsContainerRef_current_getBoundingClientRect.left,\n        nextContainerWidth = _thumbsContainerRef_current_getBoundingClientRect.width; // @ts-expect-error: TS2345 в VKUITouchEvent плохо описаны типы. `target` это просто `EventTarget`.\n\n\n    var foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);\n    var nextStartX = event.startX - nextContainerX;\n    var nextValue = offsetToValue(nextStartX, nextContainerWidth, min, max, step);\n    var nextDragging = snapDirection(value, nextValue, foundDraggingType);\n    gesture.dragging = nextDragging;\n    gesture.containerWidth = nextContainerWidth;\n    gesture.startX = nextStartX;\n    var updatedInternalStateValue = updateInternalStateValue(value, nextValue, min, max, nextDragging);\n\n    var _updatedInternalStateValue = _sliced_to_array(updatedInternalStateValue, 2),\n        nextStartValue = _updatedInternalStateValue[0],\n        nextEndValue = _updatedInternalStateValue[1];\n\n    if (thumbStartInputRef.current && (foundDraggingType === \"start\" || nextStartValue !== startValue && nextEndValue === endValue)) {\n      thumbStartInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    } else if (thumbEndInputRef.current && (foundDraggingType === \"end\" || nextEndValue !== endValue && nextStartValue === startValue)) {\n      thumbEndInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    }\n\n    changeValue(updatedInternalStateValue, event);\n    event.originalEvent.stopPropagation();\n  };\n\n  var handlePointerMove = function (event) {\n    var startX = gesture.startX,\n        containerWidth = gesture.containerWidth,\n        dragging = gesture.dragging;\n    var _event_shiftX = event.shiftX,\n        shiftX = _event_shiftX === void 0 ? 0 : _event_shiftX;\n    var nextStartX = startX + shiftX;\n    var nextValue = offsetToValue(nextStartX, containerWidth, min, max, step);\n    changeValue(updateInternalStateValue(value, nextValue, min, max, dragging), event);\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  var handlePointerEnd = function (event) {\n    gesture.dragging = null;\n    event.originalEvent.stopPropagation();\n  };\n\n  var handleChangeByNativeInput = function (event) {\n    changeValue(updateInternalStateValueByNativeChange(value, Number(event.target.value), getDraggingTypeByTargetDataset(event.target)), // @ts-expect-error: TS2345 сейчас тип расширить не получится (см. TODO в описании `onChange`)\n    event);\n  };\n\n  return /*#__PURE__*/React.createElement(Touch, _object_spread_props(_object_spread({\n    \"data-value\": multiple ? \"\".concat(startValue, \",\").concat(endValue) : startValue\n  }, restPropsWithoutAriaAttributes), {\n    className: classNames(\"vkuiSlider\", disabled && \"vkuiSlider--disabled\", sizeY !== SizeType.REGULAR && sizeYClassNames[sizeY], className),\n    onStart: disabled ? undefined : handlePointerStart,\n    onMove: disabled ? undefined : handlePointerMove,\n    onEnd: disabled ? undefined : handlePointerEnd\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiSlider__track\"\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiSlider__track-fill\",\n    style: multiple ? {\n      left: \"\".concat(startValueInPercent, \"%\"),\n      right: \"\".concat(100 - endReversedValueInPercent, \"%\")\n    } : {\n      width: \"\".concat(startValueInPercent, \"%\")\n    }\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    ref: thumbsContainerRef,\n    className: \"vkuiSlider__thumbs\"\n  }, /*#__PURE__*/React.createElement(SliderThumb, {\n    \"data-type\": \"start\",\n    className: \"vkuiSlider__thumb\",\n    style: {\n      left: \"\".concat(startValueInPercent, \"%\"),\n      // Меняем местами порядок слоёв, иначе, при достижении `start` и `end` 100%, `end` будет перекрывать `start`.\n      zIndex: multiple && startValueInPercent >= 50 ? 2 : undefined\n    },\n    withTooltip: withTooltip,\n    inputProps: {\n      \"data-type\": \"start\",\n      \"ref\": thumbStartInputRef,\n      \"step\": step,\n      \"min\": min,\n      \"value\": startValue,\n      \"max\": multiple ? endValue : max,\n      \"disabled\": disabled,\n      \"aria-label\": getAriaLabel ? getAriaLabel(0) : ariaLabel,\n      \"aria-valuetext\": getAriaValueText ? getAriaValueText(startValue, 0) : ariaValueText,\n      \"aria-labelledby\": ariaLabelledBy,\n      \"onChange\": handleChangeByNativeInput\n    }\n  }), multiple && /*#__PURE__*/React.createElement(SliderThumb, {\n    \"data-type\": \"end\",\n    className: \"vkuiSlider__thumb\",\n    style: {\n      left: \"\".concat(endReversedValueInPercent, \"%\")\n    },\n    withTooltip: withTooltip,\n    inputProps: {\n      \"data-type\": \"end\",\n      \"ref\": thumbEndInputRef,\n      \"step\": step,\n      \"min\": startValue,\n      \"value\": endValue,\n      \"max\": max,\n      \"disabled\": disabled,\n      \"aria-label\": getAriaLabel ? getAriaLabel(1) : ariaLabel,\n      \"aria-valuetext\": getAriaValueText ? getAriaValueText(endValue, 1) : ariaValueText,\n      \"aria-labelledby\": ariaLabelledBy,\n      \"onChange\": handleChangeByNativeInput\n    }\n  })));\n};","map":{"version":3,"mappings":"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","names":["React","classNames","clamp","useAdaptivity","useExternRef","SizeType","Touch","SliderThumb","extractSliderAriaAttributesFromRestProps","getDraggingTypeByTargetDataset","isMultipleValues","offsetToValue","snapDirection","toPercent","updateInternalStateValue","updateInternalStateValueByNativeChange","sizeYClassNames","none","COMPACT","Slider","step","min","_param_min","_param_max","max","value","valueProp","multiple","multipleProp","defaultValue","disabled","className","getRootRef","getAriaLabel","getAriaValueText","onChange","withTooltip","restProps","sizeY","_useAdaptivity_sizeY","isControlled","undefined","useState","localValue","setValue","useMemo","resolvedValue","Array","isArray","startValue","endValue","startValueInPercent","endReversedValueInPercent","gesture","useRef","dragging","startX","containerWidth","current","thumbsContainerRef","thumbStartInputRef","thumbEndInputRef","ariaLabel","ariaValueText","ariaLabelledBy","restPropsWithoutAriaAttributes","changeValue","nextValue","event","handlePointerStart","getBoundingClientRect","left","nextContainerX","width","nextContainerWidth","foundDraggingType","originalEvent","target","nextStartX","nextDragging","updatedInternalStateValue","nextStartValue","nextEndValue","focus","preventDefault","stopPropagation","handlePointerMove","shiftX","_event_shiftX","handlePointerEnd","handleChangeByNativeInput","Number","data-value","concat","REGULAR","onStart","onMove","onEnd","div","style","right","ref","data-type","zIndex","inputProps"],"sources":["C:\\Users\\kulag\\vk\\Ability\\node_modules\\@vkontakte\\vkui\\src\\components\\Slider\\Slider.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { clamp } from '../../helpers/math';\nimport { useAdaptivity } from '../../hooks/useAdaptivity';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport { SizeType } from '../../lib/adaptivity';\nimport { HTMLAttributesWithRootRef } from '../../types';\nimport { Touch, type TouchEvent, type TouchEventHandler } from '../Touch/Touch';\nimport { SliderThumb } from './SliderThumb/SliderThumb';\nimport {\n  extractSliderAriaAttributesFromRestProps,\n  getDraggingTypeByTargetDataset,\n  isMultipleValues,\n  offsetToValue,\n  snapDirection,\n  toPercent,\n  updateInternalStateValue,\n  updateInternalStateValueByNativeChange,\n} from './helpers';\nimport type { InternalGestureRef, InternalValueState } from './types';\nimport styles from './Slider.module.css';\n\nconst sizeYClassNames = {\n  none: styles['Slider--sizeY-none'],\n  [SizeType.COMPACT]: styles['Slider--sizeY-compact'],\n};\n\nexport interface SliderBaseProps\n  extends Omit<HTMLAttributesWithRootRef<HTMLDivElement>, 'value' | 'defaultValue' | 'onChange'> {\n  min?: number;\n  max?: number;\n  step?: number;\n  disabled?: boolean;\n  /**\n   * Тоже самое, что и `aria-label`, но на вход можно получать индекс текущего ползунка и в зависимости от этого выдавать разный текст.\n   *\n   * > Перебивает `aria-label`.\n   */\n  getAriaLabel?(index: number): string;\n  /**\n   * В отличие от `aria-valuetext`, позволяет более гибко форматировать текст в зависимости от значения ползунка.\n   *\n   * Полезно при использовании компонента как неконтролируемого.\n   *\n   * > Перебивает `aria-valuetext`.\n   */\n  getAriaValueText?(value: number, index: number): string;\n  withTooltip?: boolean;\n}\n\nexport interface SliderProps extends SliderBaseProps {\n  multiple?: false;\n  value?: number;\n  defaultValue?: number;\n  /**\n   * TODO [>=6]: Расширить тип `event` с `React.ChangeEvent`.\n   */\n  onChange?(value: number, event: TouchEvent): void;\n}\n\nexport interface SliderMultipleProps extends SliderBaseProps {\n  multiple: true;\n  value?: [number, number];\n  defaultValue?: [number, number];\n  /**\n   * TODO [>=6]: Расширить тип `event` с `React.ChangeEvent`.\n   */\n  onChange?(value: [number, number], event: TouchEvent): void;\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/Slider\n */\nexport const Slider = ({\n  // TODO [>=6]: Выставить 1 как значение по умолчанию, чтобы было как в браузерном <input type=\"range\" />\n  step,\n  min = 0,\n  max = 100,\n  value: valueProp,\n  multiple: multipleProp,\n  defaultValue = multipleProp ? [min, max] : min,\n  disabled,\n  className,\n  getRootRef,\n  getAriaLabel,\n  getAriaValueText,\n  onChange,\n  withTooltip,\n  ...restProps\n}: SliderProps | SliderMultipleProps) => {\n  const { sizeY = 'none' } = useAdaptivity();\n\n  const isControlled = valueProp !== undefined;\n  const [localValue, setValue] = React.useState(defaultValue);\n\n  const value = React.useMemo<InternalValueState>(() => {\n    const resolvedValue = isControlled ? valueProp : localValue;\n    return Array.isArray(resolvedValue)\n      ? [clamp(resolvedValue[0], min, max), clamp(resolvedValue[1], min, max)]\n      : [clamp(resolvedValue, min, max), null];\n  }, [isControlled, valueProp, localValue, min, max]);\n\n  const [startValue, endValue] = value;\n  const multiple = multipleProp && endValue !== null;\n  const startValueInPercent = toPercent(startValue, min, max);\n  const endReversedValueInPercent = multiple ? toPercent(endValue, min, max) : 0;\n\n  const gesture = React.useRef<InternalGestureRef>({\n    dragging: null,\n    startX: 0,\n    containerWidth: 0,\n  }).current;\n  const thumbsContainerRef = useExternRef(getRootRef);\n  const thumbStartInputRef = React.useRef<HTMLInputElement>(null);\n  const thumbEndInputRef = React.useRef<HTMLInputElement>(null);\n\n  const { ariaLabel, ariaValueText, ariaLabelledBy, ...restPropsWithoutAriaAttributes } =\n    extractSliderAriaAttributesFromRestProps(restProps);\n\n  const changeValue = (nextValue: InternalValueState, event: TouchEvent) => {\n    if (disabled || (value[0] === nextValue[0] && value[1] === nextValue[1])) {\n      return;\n    }\n\n    if (multipleProp) {\n      if (isMultipleValues(nextValue)) {\n        !isControlled && setValue(nextValue);\n        onChange && onChange(nextValue, event);\n      }\n    } else {\n      !isControlled && setValue(nextValue[0]);\n      onChange && onChange(nextValue[0], event);\n    }\n  };\n\n  const handlePointerStart: TouchEventHandler = (event: TouchEvent) => {\n    if (!thumbsContainerRef.current) {\n      return;\n    }\n\n    const { left: nextContainerX, width: nextContainerWidth } =\n      thumbsContainerRef.current.getBoundingClientRect();\n\n    // @ts-expect-error: TS2345 в VKUITouchEvent плохо описаны типы. `target` это просто `EventTarget`.\n    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);\n\n    const nextStartX = event.startX - nextContainerX;\n    const nextValue = offsetToValue(nextStartX, nextContainerWidth, min, max, step);\n    const nextDragging = snapDirection(value, nextValue, foundDraggingType);\n\n    gesture.dragging = nextDragging;\n    gesture.containerWidth = nextContainerWidth;\n    gesture.startX = nextStartX;\n\n    const updatedInternalStateValue = updateInternalStateValue(\n      value,\n      nextValue,\n      min,\n      max,\n      nextDragging,\n    );\n\n    const [nextStartValue, nextEndValue] = updatedInternalStateValue;\n    if (\n      thumbStartInputRef.current &&\n      (foundDraggingType === 'start' ||\n        (nextStartValue !== startValue && nextEndValue === endValue))\n    ) {\n      thumbStartInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    } else if (\n      thumbEndInputRef.current &&\n      (foundDraggingType === 'end' || (nextEndValue !== endValue && nextStartValue === startValue))\n    ) {\n      thumbEndInputRef.current.focus();\n      event.originalEvent.preventDefault();\n    }\n\n    changeValue(updatedInternalStateValue, event);\n\n    event.originalEvent.stopPropagation();\n  };\n\n  const handlePointerMove: TouchEventHandler = (event: TouchEvent) => {\n    const { startX, containerWidth, dragging } = gesture;\n\n    const { shiftX = 0 } = event;\n    const nextStartX = startX + shiftX;\n    const nextValue = offsetToValue(nextStartX, containerWidth, min, max, step);\n\n    changeValue(updateInternalStateValue(value, nextValue, min, max, dragging), event);\n\n    event.originalEvent.stopPropagation();\n    event.originalEvent.preventDefault();\n  };\n\n  const handlePointerEnd: TouchEventHandler = (event) => {\n    gesture.dragging = null;\n    event.originalEvent.stopPropagation();\n  };\n\n  const handleChangeByNativeInput = (event: React.ChangeEvent<HTMLInputElement>) => {\n    changeValue(\n      updateInternalStateValueByNativeChange(\n        value,\n        Number(event.target.value),\n        getDraggingTypeByTargetDataset(event.target),\n      ),\n      // @ts-expect-error: TS2345 сейчас тип расширить не получится (см. TODO в описании `onChange`)\n      event,\n    );\n  };\n\n  return (\n    <Touch\n      data-value={multiple ? `${startValue},${endValue}` : startValue}\n      {...restPropsWithoutAriaAttributes}\n      className={classNames(\n        styles['Slider'],\n        disabled && styles['Slider--disabled'],\n        sizeY !== SizeType.REGULAR && sizeYClassNames[sizeY],\n        className,\n      )}\n      onStart={disabled ? undefined : handlePointerStart}\n      onMove={disabled ? undefined : handlePointerMove}\n      onEnd={disabled ? undefined : handlePointerEnd}\n    >\n      <div className={styles['Slider__track']} />\n      <div\n        className={styles['Slider__track-fill']}\n        style={\n          multiple\n            ? { left: `${startValueInPercent}%`, right: `${100 - endReversedValueInPercent}%` }\n            : { width: `${startValueInPercent}%` }\n        }\n      />\n      <div ref={thumbsContainerRef} className={styles['Slider__thumbs']}>\n        <SliderThumb\n          data-type=\"start\"\n          className={styles['Slider__thumb']}\n          style={{\n            left: `${startValueInPercent}%`,\n            // Меняем местами порядок слоёв, иначе, при достижении `start` и `end` 100%, `end` будет перекрывать `start`.\n            zIndex: multiple && startValueInPercent >= 50 ? 2 : undefined,\n          }}\n          withTooltip={withTooltip}\n          inputProps={{\n            'data-type': 'start',\n            'ref': thumbStartInputRef,\n            'step': step,\n            'min': min,\n            'value': startValue,\n            'max': multiple ? endValue : max,\n            'disabled': disabled,\n            'aria-label': getAriaLabel ? getAriaLabel(0) : ariaLabel,\n            'aria-valuetext': getAriaValueText ? getAriaValueText(startValue, 0) : ariaValueText,\n            'aria-labelledby': ariaLabelledBy,\n            'onChange': handleChangeByNativeInput,\n          }}\n        />\n        {multiple && (\n          <SliderThumb\n            data-type=\"end\"\n            className={styles['Slider__thumb']}\n            style={{ left: `${endReversedValueInPercent}%` }}\n            withTooltip={withTooltip}\n            inputProps={{\n              'data-type': 'end',\n              'ref': thumbEndInputRef,\n              'step': step,\n              'min': startValue,\n              'value': endValue,\n              'max': max,\n              'disabled': disabled,\n              'aria-label': getAriaLabel ? getAriaLabel(1) : ariaLabel,\n              'aria-valuetext': getAriaValueText ? getAriaValueText(endValue, 1) : ariaValueText,\n              'aria-labelledby': ariaLabelledBy,\n              'onChange': handleChangeByNativeInput,\n            }}\n          />\n        )}\n      </div>\n    </Touch>\n  );\n};\n"]},"metadata":{},"sourceType":"module"}