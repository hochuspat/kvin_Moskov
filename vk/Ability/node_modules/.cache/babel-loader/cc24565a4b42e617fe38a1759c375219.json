{"ast":null,"code":"export var clamp = function (value, min, max) {\n  return Math.max(min, Math.min(value, max));\n};\nexport function precisionRound(number) {\n  var precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;\n  var factor = Math.pow(10, precision);\n  return Math.round(number * factor) / factor;\n}\n/**\n * Решение скопировано без изменений у MUI:\n * https://github.com/mui/material-ui/blob/v5.13.7/packages/mui-base/src/useSlider/useSlider.ts#L89-L105\n */\n\nfunction getDecimalPrecision(num) {\n  // This handles the case when num is very small (0.00000001), js will turn this into 1e-8.\n  // When num is bigger than 1 or less than -1 it won't get converted to this notation so it's fine.\n  if (Math.abs(num) < 1) {\n    var parts = num.toExponential().split(\"e-\");\n    var matissaDecimalPart = parts[0].split(\".\")[1];\n    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);\n  }\n\n  var decimalPart = num.toString().split(\".\")[1];\n  return decimalPart ? decimalPart.length : 0;\n}\n\nfunction roundValueToStep(value, step, min) {\n  var nearest = Math.round((value - min) / step) * step + min;\n  return Number(nearest.toFixed(getDecimalPrecision(step)));\n}\n\nfunction decimatedClamp(val, min, max, step) {\n  if (step == null || step <= 0) {\n    return clamp(val, min, max);\n  }\n\n  var roundedValue = roundValueToStep(val, step, min);\n  return clamp(roundedValue, min, max);\n}\n\nexport function rescale(value, from, to) {\n  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n  var scaled = (value - from[0]) / (from[1] - from[0]) * (to[1] - to[0]) + to[0];\n  return decimatedClamp(scaled, to[0], to[1], options.step);\n}","map":{"version":3,"mappings":"AAAA,OAAO,IAAMA,QAAQ,UAACC,KAAD,EAAgBC,GAAhB,EAA6BC,GAA7B,EAA6BA;SAChDC,KAAKD,GAALC,CAASF,GAATE,EAAcA,KAAKF,GAALE,CAASH,KAATG,EAAgBD,GAAhBC,CAAdA;CADK;AAGP,OAAO,SAASC,cAAT,CAAwBC,MAAxB,EAAsC;MAAEC,6EAAY;EACzD,IAAIC,SAASJ,KAAKK,GAALL,CAAS,EAATA,EAAaG,SAAbH,CAAb;EACA,OAAOA,KAAKM,KAALN,CAAWE,SAASE,MAApBJ,IAA8BI,MAArC;AACF;AAEA;;;;;AAIA,SAASG,mBAAT,CAA6BC,GAA7B,EAAwC;EACtC;EACA;EACA,IAAIR,KAAKS,GAALT,CAASQ,GAATR,IAAgB,CAApB,EAAuB;IACrB,IAAMU,QAAQF,IAAIG,aAAJH,GAAoBI,KAApBJ,CAA0B,IAA1BA,CAAd;IACA,IAAMK,qBAAqBH,KAAK,CAAC,CAAD,CAALA,CAASE,KAATF,CAAe,GAAfA,EAAoB,CAApBA,CAA3B;IACA,OAAO,CAACG,qBAAqBA,mBAAmBC,MAAxCD,GAAiD,CAAlD,IAAuDE,SAASL,KAAK,CAAC,CAAD,CAAdK,EAAmB,EAAnBA,CAA9D;EACF;;EAEA,IAAMC,cAAcR,IAAIS,QAAJT,GAAeI,KAAfJ,CAAqB,GAArBA,EAA0B,CAA1BA,CAApB;EACA,OAAOQ,cAAcA,YAAYF,MAA1BE,GAAmC,CAA1C;AACF;;AAEA,SAASE,gBAAT,CAA0BrB,KAA1B,EAAyCsB,IAAzC,EAAuDrB,GAAvD,EAAkE;EAChE,IAAMsB,UAAUpB,KAAKM,KAALN,CAAW,CAACH,QAAQC,GAAT,IAAgBqB,IAA3BnB,IAAmCmB,IAAnCnB,GAA0CF,GAA1D;EACA,OAAOuB,OAAOD,QAAQE,OAARF,CAAgBb,oBAAoBY,IAApBZ,CAAhBa,CAAPC,CAAP;AACF;;AAEA,SAASE,cAAT,CAAwBC,GAAxB,EAAqC1B,GAArC,EAAkDC,GAAlD,EAA+DoB,IAA/D,EAA4E;EAC1E,IAAIA,QAAQ,IAARA,IAAgBA,QAAQ,CAA5B,EAA+B;IAC7B,OAAOvB,MAAM4B,GAAN5B,EAAWE,GAAXF,EAAgBG,GAAhBH,CAAP;EACF;;EACA,IAAM6B,eAAeP,iBAAiBM,GAAjBN,EAAsBC,IAAtBD,EAA4BpB,GAA5BoB,CAArB;EACA,OAAOtB,MAAM6B,YAAN7B,EAAoBE,GAApBF,EAAyBG,GAAzBH,CAAP;AACF;;AAEA,OAAO,SAAS8B,OAAT,CACL7B,KADK,EAEL8B,IAFK,EAGLC,EAHK,EAGe;MACpBC,2EAA6B;EAE7B,IAAMC,SAAS,CAAEjC,QAAQ8B,IAAI,CAAC,CAAD,CAAd,KAAsBA,IAAI,CAAC,CAAD,CAAJA,GAAUA,IAAI,CAAC,CAAD,CAApC,KAA6CC,EAAE,CAAC,CAAD,CAAFA,GAAQA,EAAE,CAAC,CAAD,CAAvD,IAA8DA,EAAE,CAAC,CAAD,CAA/E;EACA,OAAOL,eAAeO,MAAfP,EAAuBK,EAAE,CAAC,CAAD,CAAzBL,EAA8BK,EAAE,CAAC,CAAD,CAAhCL,EAAqCM,QAAQV,IAA7CI,CAAP;AACF","names":["clamp","value","min","max","Math","precisionRound","number","precision","factor","pow","round","getDecimalPrecision","num","abs","parts","toExponential","split","matissaDecimalPart","length","parseInt","decimalPart","toString","roundValueToStep","step","nearest","Number","toFixed","decimatedClamp","val","roundedValue","rescale","from","to","options","scaled"],"sources":["C:\\Users\\kulag\\vk\\Ability\\node_modules\\@vkontakte\\vkui\\src\\helpers\\math.ts"],"sourcesContent":["export const clamp = (value: number, min: number, max: number) =>\n  Math.max(min, Math.min(value, max));\n\nexport function precisionRound(number: number, precision = 1) {\n  let factor = Math.pow(10, precision);\n  return Math.round(number * factor) / factor;\n}\n\n/**\n * Решение скопировано без изменений у MUI:\n * https://github.com/mui/material-ui/blob/v5.13.7/packages/mui-base/src/useSlider/useSlider.ts#L89-L105\n */\nfunction getDecimalPrecision(num: number) {\n  // This handles the case when num is very small (0.00000001), js will turn this into 1e-8.\n  // When num is bigger than 1 or less than -1 it won't get converted to this notation so it's fine.\n  if (Math.abs(num) < 1) {\n    const parts = num.toExponential().split('e-');\n    const matissaDecimalPart = parts[0].split('.')[1];\n    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);\n  }\n\n  const decimalPart = num.toString().split('.')[1];\n  return decimalPart ? decimalPart.length : 0;\n}\n\nfunction roundValueToStep(value: number, step: number, min: number) {\n  const nearest = Math.round((value - min) / step) * step + min;\n  return Number(nearest.toFixed(getDecimalPrecision(step)));\n}\n\nfunction decimatedClamp(val: number, min: number, max: number, step?: number) {\n  if (step == null || step <= 0) {\n    return clamp(val, min, max);\n  }\n  const roundedValue = roundValueToStep(val, step, min);\n  return clamp(roundedValue, min, max);\n}\n\nexport function rescale(\n  value: number,\n  from: [number, number],\n  to: [number, number],\n  options: { step?: number } = {},\n) {\n  const scaled = ((value - from[0]) / (from[1] - from[0])) * (to[1] - to[0]) + to[0];\n  return decimatedClamp(scaled, to[0], to[1], options.step);\n}\n"]},"metadata":{},"sourceType":"module"}