{"ast":null,"code":"import { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _sliced_to_array } from \"@swc/helpers/_/_sliced_to_array\";\nimport * as React from \"react\";\nimport { classNames, noop } from \"@vkontakte/vkjs\";\nimport { useAdaptivityHasPointer } from \"../../hooks/useAdaptivityHasPointer\";\nimport { useDirection } from \"../../hooks/useDirection\";\nimport { useEventListener } from \"../../hooks/useEventListener\";\nimport { useExternRef } from \"../../hooks/useExternRef\";\nimport { easeInOutSine } from \"../../lib/fx\";\nimport { RootComponent } from \"../RootComponent/RootComponent\";\nimport { ScrollArrow } from \"../ScrollArrow/ScrollArrow\";\n/**\n * timing method\n */\n\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n/**\n * Округление к большему по модулю\n *\n * ## Пример\n *\n * ```ts\n * import { strict as assert } from 'node:assert';\n *\n * assert.equal(roundingAwayFromZero(5.1), 6)\n * assert.equal(roundingAwayFromZero(-5.1), -6)\n * ```\n */\n\n\nfunction roundingAwayFromZero(value) {\n  return value > 0 ? Math.ceil(value) : Math.floor(value);\n}\n/**\n * Округляем el.scrollLeft\n * https://github.com/VKCOM/VKUI/pull/2445\n */\n\n\nvar roundUpElementScrollLeft = function (el) {\n  return roundingAwayFromZero(el.scrollLeft);\n};\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\n\n\nvar SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll(param) {\n  var scrollElement = param.scrollElement,\n      getScrollPosition = param.getScrollPosition,\n      animationQueue = param.animationQueue,\n      onScrollToEndBorder = param.onScrollToEndBorder,\n      onScrollEnd = param.onScrollEnd,\n      onScrollStart = param.onScrollStart,\n      initialScrollWidth = param.initialScrollWidth,\n      _param_scrollAnimationDuration = param.scrollAnimationDuration,\n      scrollAnimationDuration = _param_scrollAnimationDuration === void 0 ? SCROLL_ONE_FRAME_TIME : _param_scrollAnimationDuration,\n      textDirection = param.textDirection;\n\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n  /**\n  * крайнее значение сдвига\n  */\n\n\n  var extremeScrollLeft = (textDirection === \"ltr\" ? 1 : -1) * (initialScrollWidth - scrollElement.offsetWidth);\n  var startScrollLeft = roundUpElementScrollLeft(scrollElement);\n  var endScrollLeft = getScrollPosition(startScrollLeft);\n  onScrollStart();\n  /**\n  * Если окончание прокрутки вышло за ноль\n  */\n\n  if (startScrollLeft * endScrollLeft < 0) {\n    endScrollLeft = 0;\n  }\n\n  if (Math.abs(endScrollLeft) >= Math.abs(extremeScrollLeft)) {\n    onScrollToEndBorder();\n    endScrollLeft = extremeScrollLeft;\n  }\n\n  var startTime = now();\n\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n\n    var time = now();\n    var elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n    var value = easeInOutSine(elapsed);\n    var currentScrollLeft = startScrollLeft + (endScrollLeft - startScrollLeft) * value;\n    scrollElement.scrollLeft = roundingAwayFromZero(currentScrollLeft);\n    var scrollEnd = textDirection === \"ltr\" ? Math.max(0, endScrollLeft) : Math.min(0, endScrollLeft);\n\n    if (roundUpElementScrollLeft(scrollElement) !== scrollEnd && elapsed !== 1) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n/**\n * @see https://vkcom.github.io/VKUI/#/HorizontalScroll\n */\n\n\nexport var HorizontalScroll = function (_param) {\n  var children = _param.children,\n      getScrollToLeft = _param.getScrollToLeft,\n      getScrollToRight = _param.getScrollToRight,\n      _param_showArrows = _param.showArrows,\n      showArrows = _param_showArrows === void 0 ? true : _param_showArrows,\n      _param_arrowSize = _param.arrowSize,\n      arrowSize = _param_arrowSize === void 0 ? \"l\" : _param_arrowSize,\n      arrowOffsetY = _param.arrowOffsetY,\n      _param_scrollAnimationDuration = _param.scrollAnimationDuration,\n      scrollAnimationDuration = _param_scrollAnimationDuration === void 0 ? SCROLL_ONE_FRAME_TIME : _param_scrollAnimationDuration,\n      getRef = _param.getRef,\n      _param_scrollOnAnyWheel = _param.scrollOnAnyWheel,\n      scrollOnAnyWheel = _param_scrollOnAnyWheel === void 0 ? false : _param_scrollOnAnyWheel,\n      restProps = _object_without_properties(_param, [\"children\", \"getScrollToLeft\", \"getScrollToRight\", \"showArrows\", \"arrowSize\", \"arrowOffsetY\", \"scrollAnimationDuration\", \"getRef\", \"scrollOnAnyWheel\"]);\n\n  var _React_useState = _sliced_to_array(React.useState(false), 2),\n      canScrollLeft = _React_useState[0],\n      setCanScrollLeft = _React_useState[1];\n\n  var _React_useState1 = _sliced_to_array(React.useState(false), 2),\n      canScrollRight = _React_useState1[0],\n      setCanScrollRight = _React_useState1[1];\n\n  var _useDirection = _sliced_to_array(useDirection(), 2),\n      directionRef = _useDirection[0],\n      tmp = _useDirection[1],\n      textDirection = tmp === void 0 ? \"ltr\" : tmp;\n\n  var setCanScrollStart = textDirection === \"ltr\" ? setCanScrollLeft : setCanScrollRight;\n  var setCanScrollEnd = textDirection === \"ltr\" ? setCanScrollRight : setCanScrollLeft;\n  var isCustomScrollingRef = React.useRef(false);\n  var scrollerRef = useExternRef(getRef, directionRef);\n  var animationQueue = React.useRef([]);\n  var hasPointer = useAdaptivityHasPointer();\n  var scrollTo = React.useCallback(function (getScrollPosition) {\n    var scrollElement = scrollerRef.current;\n    animationQueue.current.push(function () {\n      var _scrollElement_firstElementChild;\n\n      return doScroll({\n        scrollElement: scrollElement,\n        getScrollPosition: getScrollPosition,\n        animationQueue: animationQueue.current,\n        onScrollToEndBorder: function () {\n          return setCanScrollEnd(false);\n        },\n        onScrollEnd: function () {\n          return isCustomScrollingRef.current = false;\n        },\n        onScrollStart: function () {\n          return isCustomScrollingRef.current = true;\n        },\n        initialScrollWidth: (scrollElement === null || scrollElement === void 0 ? void 0 : (_scrollElement_firstElementChild = scrollElement.firstElementChild) === null || _scrollElement_firstElementChild === void 0 ? void 0 : _scrollElement_firstElementChild.scrollWidth) || 0,\n        scrollAnimationDuration: scrollAnimationDuration,\n        textDirection: textDirection\n      });\n    });\n\n    if (animationQueue.current.length === 1) {\n      animationQueue.current[0]();\n    }\n  }, [scrollerRef, scrollAnimationDuration, textDirection, setCanScrollEnd]);\n  var scrollToLeft = React.useCallback(function () {\n    var getScrollPosition = getScrollToLeft !== null && getScrollToLeft !== void 0 ? getScrollToLeft : function (i) {\n      return i - scrollerRef.current.offsetWidth;\n    };\n    scrollTo(getScrollPosition);\n  }, [getScrollToLeft, scrollTo, scrollerRef]);\n  var scrollToRight = React.useCallback(function () {\n    var getScrollPosition = getScrollToRight !== null && getScrollToRight !== void 0 ? getScrollToRight : function (i) {\n      return i + scrollerRef.current.offsetWidth;\n    };\n    scrollTo(getScrollPosition);\n  }, [getScrollToRight, scrollTo, scrollerRef]);\n  var calculateArrowsVisibility = React.useCallback(function () {\n    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {\n      var scrollElement = scrollerRef.current;\n      setCanScrollStart(scrollElement.scrollLeft !== 0);\n      setCanScrollEnd(Math.abs(roundUpElementScrollLeft(scrollElement)) + scrollElement.offsetWidth < scrollElement.scrollWidth);\n    }\n  }, [showArrows, hasPointer, scrollerRef, setCanScrollStart, setCanScrollEnd]);\n  var scrollEvent = useEventListener(\"scroll\", calculateArrowsVisibility);\n  React.useEffect(function addScrollerRefToScrollEvent() {\n    if (!scrollerRef.current) {\n      return noop;\n    }\n\n    scrollEvent.add(scrollerRef.current);\n    return scrollEvent.remove;\n  }, [scrollEvent, scrollerRef]);\n  React.useEffect(calculateArrowsVisibility, [calculateArrowsVisibility, children]);\n  /**\n  * Прокрутка с помощью любого колеса мыши\n  */\n\n  var onwheel = React.useCallback(function (e) {\n    scrollerRef.current.scrollBy({\n      left: e.deltaX + e.deltaY,\n      behavior: \"auto\"\n    });\n    e.preventDefault();\n  }, [scrollerRef]);\n  var wheelEvent = useEventListener(\"wheel\", onwheel);\n  React.useEffect(function addScrollerRefToWheelEvent() {\n    if (!scrollerRef.current || !scrollOnAnyWheel) {\n      return noop;\n    }\n\n    wheelEvent.add(scrollerRef.current);\n    return wheelEvent.remove;\n  }, [wheelEvent, scrollerRef, scrollOnAnyWheel]);\n  return /*#__PURE__*/React.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {\n    baseClassName: classNames(\"vkuiHorizontalScroll\", \"vkuiInternalHorizontalScroll\", showArrows === \"always\" && \"vkuiHorizontalScroll--withConstArrows\"),\n    onMouseEnter: calculateArrowsVisibility\n  }), showArrows && (hasPointer || hasPointer === undefined) && canScrollLeft && /*#__PURE__*/React.createElement(ScrollArrow, {\n    \"data-testid\": process.env.NODE_ENV === \"test\" ? \"ScrollArrow\" : undefined,\n    size: arrowSize,\n    offsetY: arrowOffsetY,\n    direction: \"left\",\n    \"aria-hidden\": true,\n    className: classNames(\"vkuiHorizontalScroll__arrow\", \"vkuiHorizontalScroll__arrowLeft\"),\n    onClick: scrollToLeft\n  }), showArrows && (hasPointer || hasPointer === undefined) && canScrollRight && /*#__PURE__*/React.createElement(ScrollArrow, {\n    \"data-testid\": process.env.NODE_ENV === \"test\" ? \"ScrollArrow\" : undefined,\n    size: arrowSize,\n    offsetY: arrowOffsetY,\n    direction: \"right\",\n    \"aria-hidden\": true,\n    className: classNames(\"vkuiHorizontalScroll__arrow\", \"vkuiHorizontalScroll__arrowRight\"),\n    onClick: scrollToRight\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiHorizontalScroll__in\",\n    ref: scrollerRef\n  }, /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiHorizontalScroll__in-wrapper\"\n  }, children)));\n};","map":{"version":3,"mappings":"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","names":["React","classNames","noop","useAdaptivityHasPointer","useDirection","useEventListener","useExternRef","easeInOutSine","RootComponent","ScrollArrow","now","performance","Date","roundingAwayFromZero","value","Math","ceil","floor","roundUpElementScrollLeft","el","scrollLeft","SCROLL_ONE_FRAME_TIME","doScroll","param","scrollElement","getScrollPosition","animationQueue","onScrollToEndBorder","onScrollEnd","onScrollStart","initialScrollWidth","scrollAnimationDuration","textDirection","extremeScrollLeft","offsetWidth","startScrollLeft","endScrollLeft","abs","startTime","scroll","time","elapsed","min","currentScrollLeft","scrollEnd","max","requestAnimationFrame","shift","length","HorizontalScroll","children","getScrollToLeft","getScrollToRight","showArrows","_param_showArrows","_param_arrowSize","arrowSize","arrowOffsetY","getRef","scrollOnAnyWheel","_param_scrollOnAnyWheel","restProps","useState","canScrollLeft","setCanScrollLeft","canScrollRight","setCanScrollRight","directionRef","setCanScrollStart","setCanScrollEnd","isCustomScrollingRef","useRef","scrollerRef","hasPointer","scrollTo","useCallback","current","push","firstElementChild","scrollWidth","scrollToLeft","i","scrollToRight","calculateArrowsVisibility","scrollEvent","useEffect","addScrollerRefToScrollEvent","add","remove","onwheel","e","scrollBy","left","deltaX","deltaY","behavior","preventDefault","wheelEvent","addScrollerRefToWheelEvent","baseClassName","onMouseEnter","undefined","data-testid","process","env","NODE_ENV","size","offsetY","direction","aria-hidden","className","onClick","div","ref"],"sources":["C:\\Users\\kulag\\vk\\Ability\\node_modules\\@vkontakte\\vkui\\src\\components\\HorizontalScroll\\HorizontalScroll.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames, noop } from '@vkontakte/vkjs';\nimport { useAdaptivityHasPointer } from '../../hooks/useAdaptivityHasPointer';\nimport { useDirection } from '../../hooks/useDirection';\nimport { useEventListener } from '../../hooks/useEventListener';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport { easeInOutSine } from '../../lib/fx';\nimport { HasRef, HTMLAttributesWithRootRef } from '../../types';\nimport { RootComponent } from '../RootComponent/RootComponent';\nimport { ScrollArrow } from '../ScrollArrow/ScrollArrow';\nimport styles from './HorizontalScroll.module.css';\n\ninterface ScrollContext {\n  scrollElement: HTMLElement | null;\n  scrollAnimationDuration: number;\n  animationQueue: VoidFunction[];\n  getScrollPosition: (currentPosition: number) => number;\n  onScrollToEndBorder: VoidFunction;\n  onScrollEnd: VoidFunction;\n  onScrollStart: VoidFunction;\n  /**\n   * Начальная ширина прокрутки.\n   * В некоторых случаях может отличаться от текущей ширины прокрутки из-за transforms: translate\n   */\n  initialScrollWidth: number;\n  textDirection: 'ltr' | 'rtl';\n}\n\nexport type ScrollPositionHandler = (currentPosition: number) => number;\n\nexport interface HorizontalScrollProps\n  extends HTMLAttributesWithRootRef<HTMLDivElement>,\n    HasRef<HTMLDivElement> {\n  /**\n   * Функция для расчета величины прокрутки при клике на левую стрелку.\n   */\n  getScrollToLeft?: ScrollPositionHandler;\n  /**\n   * Функция для расчета величины прокрутки при клике на правую стрелку.\n   */\n  getScrollToRight?: ScrollPositionHandler;\n  arrowSize?: 'm' | 'l';\n  /**\n   * Смещает иконки кнопок навигации по вертикали.\n   */\n  arrowOffsetY?: number | string;\n  showArrows?: boolean | 'always';\n  scrollAnimationDuration?: number;\n  /**\n   * Добавляет возможность прокручивать контент на любое колесо мыши.\n   * По умолчанию прокручивается как любой горизонтальный контент через shift.\n   */\n  scrollOnAnyWheel?: boolean;\n}\n\n/**\n * timing method\n */\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n\n/**\n * Округление к большему по модулю\n *\n * ## Пример\n *\n * ```ts\n * import { strict as assert } from 'node:assert';\n *\n * assert.equal(roundingAwayFromZero(5.1), 6)\n * assert.equal(roundingAwayFromZero(-5.1), -6)\n * ```\n */\nfunction roundingAwayFromZero(value: number): number {\n  return value > 0 ? Math.ceil(value) : Math.floor(value);\n}\n\n/**\n * Округляем el.scrollLeft\n * https://github.com/VKCOM/VKUI/pull/2445\n */\nconst roundUpElementScrollLeft = (el: HTMLElement) => roundingAwayFromZero(el.scrollLeft);\n\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\nconst SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll({\n  scrollElement,\n  getScrollPosition,\n  animationQueue,\n  onScrollToEndBorder,\n  onScrollEnd,\n  onScrollStart,\n  initialScrollWidth,\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n  textDirection,\n}: ScrollContext) {\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n\n  /**\n   * крайнее значение сдвига\n   */\n  const extremeScrollLeft =\n    (textDirection === 'ltr' ? 1 : -1) * (initialScrollWidth - scrollElement.offsetWidth);\n\n  let startScrollLeft = roundUpElementScrollLeft(scrollElement);\n  let endScrollLeft = getScrollPosition(startScrollLeft);\n\n  onScrollStart();\n\n  /**\n   * Если окончание прокрутки вышло за ноль\n   */\n  if (startScrollLeft * endScrollLeft < 0) {\n    endScrollLeft = 0;\n  }\n\n  if (Math.abs(endScrollLeft) >= Math.abs(extremeScrollLeft)) {\n    onScrollToEndBorder();\n    endScrollLeft = extremeScrollLeft;\n  }\n\n  const startTime = now();\n\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n\n    const time = now();\n    const elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n\n    const value = easeInOutSine(elapsed);\n\n    const currentScrollLeft = startScrollLeft + (endScrollLeft - startScrollLeft) * value;\n    scrollElement.scrollLeft = roundingAwayFromZero(currentScrollLeft);\n\n    const scrollEnd =\n      textDirection === 'ltr' ? Math.max(0, endScrollLeft) : Math.min(0, endScrollLeft);\n    if (roundUpElementScrollLeft(scrollElement) !== scrollEnd && elapsed !== 1) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/HorizontalScroll\n */\nexport const HorizontalScroll = ({\n  children,\n  getScrollToLeft,\n  getScrollToRight,\n  showArrows = true,\n  arrowSize = 'l',\n  arrowOffsetY,\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n  getRef,\n  scrollOnAnyWheel = false,\n  ...restProps\n}: HorizontalScrollProps) => {\n  const [canScrollLeft, setCanScrollLeft] = React.useState(false);\n  const [canScrollRight, setCanScrollRight] = React.useState(false);\n  const [directionRef, textDirection = 'ltr'] = useDirection<HTMLDivElement>();\n\n  const setCanScrollStart = textDirection === 'ltr' ? setCanScrollLeft : setCanScrollRight;\n  const setCanScrollEnd = textDirection === 'ltr' ? setCanScrollRight : setCanScrollLeft;\n\n  const isCustomScrollingRef = React.useRef(false);\n\n  const scrollerRef = useExternRef(getRef, directionRef);\n\n  const animationQueue = React.useRef<VoidFunction[]>([]);\n\n  const hasPointer = useAdaptivityHasPointer();\n\n  const scrollTo = React.useCallback(\n    (getScrollPosition: ScrollPositionHandler) => {\n      const scrollElement = scrollerRef.current;\n\n      animationQueue.current.push(() =>\n        doScroll({\n          scrollElement,\n          getScrollPosition,\n          animationQueue: animationQueue.current,\n          onScrollToEndBorder: () => setCanScrollEnd(false),\n          onScrollEnd: () => (isCustomScrollingRef.current = false),\n          onScrollStart: () => (isCustomScrollingRef.current = true),\n          initialScrollWidth: scrollElement?.firstElementChild?.scrollWidth || 0,\n          scrollAnimationDuration,\n          textDirection,\n        }),\n      );\n      if (animationQueue.current.length === 1) {\n        animationQueue.current[0]();\n      }\n    },\n    [scrollerRef, scrollAnimationDuration, textDirection, setCanScrollEnd],\n  );\n\n  const scrollToLeft = React.useCallback(() => {\n    const getScrollPosition =\n      getScrollToLeft ?? ((i: number) => i - scrollerRef.current!.offsetWidth);\n    scrollTo(getScrollPosition);\n  }, [getScrollToLeft, scrollTo, scrollerRef]);\n\n  const scrollToRight = React.useCallback(() => {\n    const getScrollPosition =\n      getScrollToRight ?? ((i: number) => i + scrollerRef.current!.offsetWidth);\n    scrollTo(getScrollPosition);\n  }, [getScrollToRight, scrollTo, scrollerRef]);\n\n  const calculateArrowsVisibility = React.useCallback(() => {\n    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {\n      const scrollElement = scrollerRef.current;\n\n      setCanScrollStart(scrollElement.scrollLeft !== 0);\n      setCanScrollEnd(\n        Math.abs(roundUpElementScrollLeft(scrollElement)) + scrollElement.offsetWidth <\n          scrollElement.scrollWidth,\n      );\n    }\n  }, [showArrows, hasPointer, scrollerRef, setCanScrollStart, setCanScrollEnd]);\n\n  const scrollEvent = useEventListener('scroll', calculateArrowsVisibility);\n  React.useEffect(\n    function addScrollerRefToScrollEvent() {\n      if (!scrollerRef.current) {\n        return noop;\n      }\n\n      scrollEvent.add(scrollerRef.current);\n      return scrollEvent.remove;\n    },\n    [scrollEvent, scrollerRef],\n  );\n\n  React.useEffect(calculateArrowsVisibility, [calculateArrowsVisibility, children]);\n\n  /**\n   * Прокрутка с помощью любого колеса мыши\n   */\n  const onwheel = React.useCallback(\n    (e: WheelEvent) => {\n      scrollerRef.current!.scrollBy({ left: e.deltaX + e.deltaY, behavior: 'auto' });\n      e.preventDefault();\n    },\n    [scrollerRef],\n  );\n\n  const wheelEvent = useEventListener('wheel', onwheel);\n  React.useEffect(\n    function addScrollerRefToWheelEvent() {\n      if (!scrollerRef.current || !scrollOnAnyWheel) {\n        return noop;\n      }\n\n      wheelEvent.add(scrollerRef.current);\n\n      return wheelEvent.remove;\n    },\n    [wheelEvent, scrollerRef, scrollOnAnyWheel],\n  );\n\n  return (\n    <RootComponent\n      {...restProps}\n      baseClassName={classNames(\n        styles['HorizontalScroll'],\n        'vkuiInternalHorizontalScroll',\n        showArrows === 'always' && styles['HorizontalScroll--withConstArrows'],\n      )}\n      onMouseEnter={calculateArrowsVisibility}\n    >\n      {showArrows && (hasPointer || hasPointer === undefined) && canScrollLeft && (\n        <ScrollArrow\n          data-testid={process.env.NODE_ENV === 'test' ? 'ScrollArrow' : undefined}\n          size={arrowSize}\n          offsetY={arrowOffsetY}\n          direction=\"left\"\n          aria-hidden\n          className={classNames(\n            styles['HorizontalScroll__arrow'],\n            styles['HorizontalScroll__arrowLeft'],\n          )}\n          onClick={scrollToLeft}\n        />\n      )}\n      {showArrows && (hasPointer || hasPointer === undefined) && canScrollRight && (\n        <ScrollArrow\n          data-testid={process.env.NODE_ENV === 'test' ? 'ScrollArrow' : undefined}\n          size={arrowSize}\n          offsetY={arrowOffsetY}\n          direction=\"right\"\n          aria-hidden\n          className={classNames(\n            styles['HorizontalScroll__arrow'],\n            styles['HorizontalScroll__arrowRight'],\n          )}\n          onClick={scrollToRight}\n        />\n      )}\n      <div className={styles['HorizontalScroll__in']} ref={scrollerRef}>\n        <div className={styles['HorizontalScroll__in-wrapper']}>{children}</div>\n      </div>\n    </RootComponent>\n  );\n};\n"]},"metadata":{},"sourceType":"module"}