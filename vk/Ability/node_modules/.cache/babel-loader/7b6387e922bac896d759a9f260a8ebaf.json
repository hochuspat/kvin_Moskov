{"ast":null,"code":"import { _ as _async_to_generator } from \"@swc/helpers/_/_async_to_generator\";\nimport { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\nimport { _ as _ts_generator } from \"@swc/helpers/_/_ts_generator\";\nimport { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '../../utils/dist/floating-ui.utils.esm.js';\nexport { rectToClientRect } from '../../utils/dist/floating-ui.utils.esm.js';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  var reference = _ref.reference,\n      floating = _ref.floating;\n  var sideAxis = getSideAxis(placement);\n  var alignmentAxis = getAlignmentAxis(placement);\n  var alignLength = getAxisLength(alignmentAxis);\n  var side = getSide(placement);\n  var isVertical = sideAxis === \"y\";\n  var commonX = reference.x + reference.width / 2 - floating.width / 2;\n  var commonY = reference.y + reference.height / 2 - floating.height / 2;\n  var commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  var coords;\n\n  switch (side) {\n    case \"top\":\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n\n    case \"bottom\":\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case \"right\":\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case \"left\":\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  switch (getAlignment(placement)) {\n    case \"start\":\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n\n    case \"end\":\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n\n  return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\n\n\nvar computePosition = function () {\n  var _ref = _async_to_generator(function (reference, floating, config) {\n    var _config_placement, placement, _config_strategy, strategy, _config_middleware, middleware, platform, validMiddleware, rtl, rects, _computeCoordsFromPlacement, x, y, statefulPlacement, middlewareData, resetCount, i, _validMiddleware_i, name, fn, _ref, nextX, nextY, data, reset, _tmp, ref;\n\n    return _ts_generator(this, function (_state) {\n      switch (_state.label) {\n        case 0:\n          _config_placement = config.placement, placement = _config_placement === void 0 ? \"bottom\" : _config_placement, _config_strategy = config.strategy, strategy = _config_strategy === void 0 ? \"absolute\" : _config_strategy, _config_middleware = config.middleware, middleware = _config_middleware === void 0 ? [] : _config_middleware, platform = config.platform;\n          validMiddleware = middleware.filter(Boolean);\n          return [4, platform.isRTL == null ? void 0 : platform.isRTL(floating)];\n\n        case 1:\n          rtl = _state.sent();\n          return [4, platform.getElementRects({\n            reference: reference,\n            floating: floating,\n            strategy: strategy\n          })];\n\n        case 2:\n          rects = _state.sent();\n          _computeCoordsFromPlacement = computeCoordsFromPlacement(rects, placement, rtl), x = _computeCoordsFromPlacement.x, y = _computeCoordsFromPlacement.y;\n          statefulPlacement = placement;\n          middlewareData = {};\n          resetCount = 0;\n          i = 0;\n          _state.label = 3;\n\n        case 3:\n          if (!(i < validMiddleware.length)) return [3, 11];\n          _validMiddleware_i = validMiddleware[i], name = _validMiddleware_i.name, fn = _validMiddleware_i.fn;\n          return [4, fn({\n            x: x,\n            y: y,\n            initialPlacement: placement,\n            placement: statefulPlacement,\n            strategy: strategy,\n            middlewareData: middlewareData,\n            rects: rects,\n            platform: platform,\n            elements: {\n              reference: reference,\n              floating: floating\n            }\n          })];\n\n        case 4:\n          _ref = _state.sent(), nextX = _ref.x, nextY = _ref.y, data = _ref.data, reset = _ref.reset;\n          x = nextX != null ? nextX : x;\n          y = nextY != null ? nextY : y;\n          middlewareData = _object_spread_props(_object_spread({}, middlewareData), _define_property({}, name, _object_spread({}, middlewareData[name], data)));\n          if (!(reset && resetCount <= 50)) return [3, 10];\n          resetCount++;\n          if (!(typeof reset === \"object\")) return [3, 9];\n\n          if (reset.placement) {\n            statefulPlacement = reset.placement;\n          }\n\n          if (!reset.rects) return [3, 8];\n          if (!(reset.rects === true)) return [3, 6];\n          return [4, platform.getElementRects({\n            reference: reference,\n            floating: floating,\n            strategy: strategy\n          })];\n\n        case 5:\n          _tmp = _state.sent();\n          return [3, 7];\n\n        case 6:\n          _tmp = reset.rects;\n          _state.label = 7;\n\n        case 7:\n          rects = _tmp;\n          _state.label = 8;\n\n        case 8:\n          ref = computeCoordsFromPlacement(rects, statefulPlacement, rtl), x = ref.x, y = ref.y, ref;\n          _state.label = 9;\n\n        case 9:\n          i = -1;\n          return [3, 10];\n\n        case 10:\n          i++;\n          return [3, 3];\n\n        case 11:\n          return [2, {\n            x: x,\n            y: y,\n            placement: statefulPlacement,\n            strategy: strategy,\n            middlewareData: middlewareData\n          }];\n      }\n    });\n  });\n\n  return function computePosition(reference, floating, config) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nfunction detectOverflow(state, options) {\n  return _detectOverflow.apply(this, arguments);\n}\n\nfunction _detectOverflow() {\n  _detectOverflow =\n  /**\n  * Resolves with an object of overflow side offsets that determine how much the\n  * element is overflowing a given clipping boundary on each side.\n  * - positive = overflowing the boundary by that number of pixels\n  * - negative = how many pixels left before it will overflow\n  * - 0 = lies flush with the boundary\n  * @see https://floating-ui.com/docs/detectOverflow\n  */\n  _async_to_generator(function (state, options) {\n    var _await$platform$isEle, x, y, platform, rects, elements, strategy, _evaluate, _evaluate_boundary, boundary, _evaluate_rootBoundary, rootBoundary, _evaluate_elementContext, elementContext, _evaluate_altBoundary, altBoundary, _evaluate_padding, padding, paddingObject, altContext, element, clippingClientRect, _, _tmp, _tmp1, _tmp2, rect, offsetParent, offsetScale, _tmp3, elementClientRect, _tmp4;\n\n    return _ts_generator(this, function (_state) {\n      switch (_state.label) {\n        case 0:\n          if (options === void 0) {\n            options = {};\n          }\n\n          x = state.x, y = state.y, platform = state.platform, rects = state.rects, elements = state.elements, strategy = state.strategy;\n          _evaluate = evaluate(options, state), _evaluate_boundary = _evaluate.boundary, boundary = _evaluate_boundary === void 0 ? \"clippingAncestors\" : _evaluate_boundary, _evaluate_rootBoundary = _evaluate.rootBoundary, rootBoundary = _evaluate_rootBoundary === void 0 ? \"viewport\" : _evaluate_rootBoundary, _evaluate_elementContext = _evaluate.elementContext, elementContext = _evaluate_elementContext === void 0 ? \"floating\" : _evaluate_elementContext, _evaluate_altBoundary = _evaluate.altBoundary, altBoundary = _evaluate_altBoundary === void 0 ? false : _evaluate_altBoundary, _evaluate_padding = _evaluate.padding, padding = _evaluate_padding === void 0 ? 0 : _evaluate_padding;\n          paddingObject = getPaddingObject(padding);\n          altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n          element = elements[altBoundary ? altContext : elementContext];\n          _ = platform.getClippingRect;\n          _tmp = {};\n          return [4, platform.isElement == null ? void 0 : platform.isElement(element)];\n\n        case 1:\n          if (!((_await$platform$isEle = _state.sent()) != null ? _await$platform$isEle : true)) return [3, 2];\n          _tmp1 = element;\n          return [3, 5];\n\n        case 2:\n          _tmp2 = element.contextElement;\n          if (_tmp2) return [3, 4];\n          return [4, platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)];\n\n        case 3:\n          _tmp2 = _state.sent();\n          _state.label = 4;\n\n        case 4:\n          _tmp1 = _tmp2;\n          _state.label = 5;\n\n        case 5:\n          return [4, _.apply(platform, [(_tmp.element = _tmp1, _tmp.boundary = boundary, _tmp.rootBoundary = rootBoundary, _tmp.strategy = strategy, _tmp)])];\n\n        case 6:\n          clippingClientRect = rectToClientRect.apply(void 0, [_state.sent()]);\n          rect = elementContext === \"floating\" ? _object_spread_props(_object_spread({}, rects.floating), {\n            x: x,\n            y: y\n          }) : rects.reference;\n          return [4, platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)];\n\n        case 7:\n          offsetParent = _state.sent();\n          return [4, platform.isElement == null ? void 0 : platform.isElement(offsetParent)];\n\n        case 8:\n          if (!_state.sent()) return [3, 10];\n          return [4, platform.getScale == null ? void 0 : platform.getScale(offsetParent)];\n\n        case 9:\n          _tmp3 = _state.sent() || {\n            x: 1,\n            y: 1\n          };\n          return [3, 11];\n\n        case 10:\n          _tmp3 = {\n            x: 1,\n            y: 1\n          };\n          _state.label = 11;\n\n        case 11:\n          offsetScale = _tmp3;\n          if (!platform.convertOffsetParentRelativeRectToViewportRelativeRect) return [3, 13];\n          return [4, platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n            rect: rect,\n            offsetParent: offsetParent,\n            strategy: strategy\n          })];\n\n        case 12:\n          _tmp4 = _state.sent();\n          return [3, 14];\n\n        case 13:\n          _tmp4 = rect;\n          _state.label = 14;\n\n        case 14:\n          elementClientRect = rectToClientRect.apply(void 0, [_tmp4]);\n          return [2, {\n            top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n            bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n            left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n            right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n          }];\n      }\n    });\n  });\n  return _detectOverflow.apply(this, arguments);\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\n\n\nvar arrow = function (options) {\n  return {\n    name: \"arrow\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var x, y, placement, rects, platform, elements, middlewareData, _ref, element, _ref_padding, padding, paddingObject, coords, axis, length, arrowDimensions, isYAxis, minProp, maxProp, clientProp, endDiff, startDiff, arrowOffsetParent, clientSize, _tmp, centerToReference, largestPossiblePadding, minPadding, maxPadding, min$1, max, center, offset, shouldAddOffset, alignmentOffset, _obj, _obj1;\n\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              x = state.x, y = state.y, placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements, middlewareData = state.middlewareData; // Since `element` is required, we don't Partial<> the type.\n\n              _ref = evaluate(options, state) || {}, element = _ref.element, _ref_padding = _ref.padding, padding = _ref_padding === void 0 ? 0 : _ref_padding;\n\n              if (element == null) {\n                return [2, {}];\n              }\n\n              paddingObject = getPaddingObject(padding);\n              coords = {\n                x: x,\n                y: y\n              };\n              axis = getAlignmentAxis(placement);\n              length = getAxisLength(axis);\n              return [4, platform.getDimensions(element)];\n\n            case 1:\n              arrowDimensions = _state.sent();\n              isYAxis = axis === \"y\";\n              minProp = isYAxis ? \"top\" : \"left\";\n              maxProp = isYAxis ? \"bottom\" : \"right\";\n              clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n              endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n              startDiff = coords[axis] - rects.reference[axis];\n              return [4, platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element)];\n\n            case 2:\n              arrowOffsetParent = _state.sent();\n              clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n              _tmp = !clientSize;\n              if (_tmp) return [3, 4];\n              return [4, platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)];\n\n            case 3:\n              _tmp = !_state.sent();\n              _state.label = 4;\n\n            case 4:\n              // DOM platform can return `window` as the `offsetParent`.\n              if (_tmp) {\n                clientSize = elements.floating[clientProp] || rects.floating[length];\n              }\n\n              centerToReference = endDiff / 2 - startDiff / 2; // If the padding is large enough that it causes the arrow to no longer be\n              // centered, modify the padding so that it is centered.\n\n              largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n              minPadding = min(paddingObject[minProp], largestPossiblePadding);\n              maxPadding = min(paddingObject[maxProp], largestPossiblePadding); // Make sure the arrow doesn't overflow the floating element if the center\n              // point is outside the floating element's bounds.\n\n              min$1 = minPadding;\n              max = clientSize - arrowDimensions[length] - maxPadding;\n              center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n              offset = clamp(min$1, center, max); // If the reference is small enough that the arrow's padding causes it to\n              // to point to nothing for an aligned placement, adjust the offset of the\n              // floating element itself. To ensure `shift()` continues to take action,\n              // a single reset is performed when this is true.\n\n              shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n              alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n              return [2, (_obj1 = {}, _define_property(_obj1, axis, coords[axis] + alignmentOffset), _define_property(_obj1, \"data\", _object_spread((_obj = {}, _define_property(_obj, axis, offset), _define_property(_obj, \"centerOffset\", center - offset - alignmentOffset), _obj), shouldAddOffset && {\n                alignmentOffset: alignmentOffset\n              })), _define_property(_obj1, \"reset\", shouldAddOffset), _obj1)];\n          }\n        });\n      })();\n    }\n  };\n};\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  var allowedPlacementsSortedByAlignment = alignment ? _to_consumable_array(allowedPlacements.filter(function (placement) {\n    return getAlignment(placement) === alignment;\n  })).concat(_to_consumable_array(allowedPlacements.filter(function (placement) {\n    return getAlignment(placement) !== alignment;\n  }))) : allowedPlacements.filter(function (placement) {\n    return getSide(placement) === placement;\n  });\n  return allowedPlacementsSortedByAlignment.filter(function (placement) {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\n\n\nvar autoPlacement = function autoPlacement(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: \"autoPlacement\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE, rects, middlewareData, placement, platform, elements, _evaluate, _evaluate_crossAxis, crossAxis, alignment, _evaluate_allowedPlacements, allowedPlacements, _evaluate_autoAlignment, autoAlignment, detectOverflowOptions, placements$1, overflow, currentIndex, currentPlacement, alignmentSides, _tmp, currentOverflows, allOverflows, nextPlacement, placementsSortedByMostSpace, placementsThatFitOnEachSide, resetPlacement;\n\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              rects = state.rects, middlewareData = state.middlewareData, placement = state.placement, platform = state.platform, elements = state.elements;\n              _evaluate = evaluate(options, state), _evaluate_crossAxis = _evaluate.crossAxis, crossAxis = _evaluate_crossAxis === void 0 ? false : _evaluate_crossAxis, alignment = _evaluate.alignment, _evaluate_allowedPlacements = _evaluate.allowedPlacements, allowedPlacements = _evaluate_allowedPlacements === void 0 ? placements : _evaluate_allowedPlacements, _evaluate_autoAlignment = _evaluate.autoAlignment, autoAlignment = _evaluate_autoAlignment === void 0 ? true : _evaluate_autoAlignment, detectOverflowOptions = _object_without_properties(_evaluate, [\"crossAxis\", \"alignment\", \"allowedPlacements\", \"autoAlignment\"]);\n              placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n              return [4, detectOverflow(state, detectOverflowOptions)];\n\n            case 1:\n              overflow = _state.sent();\n              currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n              currentPlacement = placements$1[currentIndex];\n\n              if (currentPlacement == null) {\n                return [2, {}];\n              }\n\n              _tmp = [currentPlacement, rects];\n              return [4, platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)];\n\n            case 2:\n              alignmentSides = getAlignmentSides.apply(void 0, _tmp.concat([_state.sent()])); // Make `computeCoords` start from the right place.\n\n              if (placement !== currentPlacement) {\n                return [2, {\n                  reset: {\n                    placement: placements$1[0]\n                  }\n                }];\n              }\n\n              currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n              allOverflows = _to_consumable_array(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []).concat([{\n                placement: currentPlacement,\n                overflows: currentOverflows\n              }]);\n              nextPlacement = placements$1[currentIndex + 1]; // There are more placements to check.\n\n              if (nextPlacement) {\n                return [2, {\n                  data: {\n                    index: currentIndex + 1,\n                    overflows: allOverflows\n                  },\n                  reset: {\n                    placement: nextPlacement\n                  }\n                }];\n              }\n\n              placementsSortedByMostSpace = allOverflows.map(function (d) {\n                var alignment = getAlignment(d.placement);\n                return [d.placement, alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.\n                d.overflows.slice(0, 2).reduce(function (acc, v) {\n                  return acc + v;\n                }, 0) : // Check only the mainAxis.\n                d.overflows[0], d.overflows];\n              }).sort(function (a, b) {\n                return a[1] - b[1];\n              });\n              placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(function (d) {\n                return d[2].slice(0, // Aligned placements should not check their opposite crossAxis\n                // side.\n                getAlignment(d[0]) ? 2 : 3).every(function (v) {\n                  return v <= 0;\n                });\n              });\n              resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n\n              if (resetPlacement !== placement) {\n                return [2, {\n                  data: {\n                    index: currentIndex + 1,\n                    overflows: allOverflows\n                  },\n                  reset: {\n                    placement: resetPlacement\n                  }\n                }];\n              }\n\n              return [2, {}];\n          }\n        });\n      })();\n    }\n  };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\n\n\nvar flip = function flip(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: \"flip\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var _middlewareData$arrow, _middlewareData$flip, placement, middlewareData, rects, initialPlacement, platform, elements, _evaluate, tmp, checkMainAxis, tmp1, checkCrossAxis, specifiedFallbackPlacements, _evaluate_fallbackStrategy, fallbackStrategy, _evaluate_fallbackAxisSideDirection, fallbackAxisSideDirection, _evaluate_flipAlignment, flipAlignment, detectOverflowOptions, side, isBasePlacement, rtl, fallbackPlacements, _fallbackPlacements, placements, overflow, overflows, overflowsData, sides, _middlewareData$flip2, _overflowsData$filter, nextIndex, nextPlacement, resetPlacement, _overflowsData$map$so, placement1;\n\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              placement = state.placement, middlewareData = state.middlewareData, rects = state.rects, initialPlacement = state.initialPlacement, platform = state.platform, elements = state.elements;\n              _evaluate = evaluate(options, state), tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? true : tmp1, specifiedFallbackPlacements = _evaluate.fallbackPlacements, _evaluate_fallbackStrategy = _evaluate.fallbackStrategy, fallbackStrategy = _evaluate_fallbackStrategy === void 0 ? \"bestFit\" : _evaluate_fallbackStrategy, _evaluate_fallbackAxisSideDirection = _evaluate.fallbackAxisSideDirection, fallbackAxisSideDirection = _evaluate_fallbackAxisSideDirection === void 0 ? \"none\" : _evaluate_fallbackAxisSideDirection, _evaluate_flipAlignment = _evaluate.flipAlignment, flipAlignment = _evaluate_flipAlignment === void 0 ? true : _evaluate_flipAlignment, detectOverflowOptions = _object_without_properties(_evaluate, [\"mainAxis\", \"crossAxis\", \"fallbackPlacements\", \"fallbackStrategy\", \"fallbackAxisSideDirection\", \"flipAlignment\"]); // If a reset by the arrow was caused due to an alignment offset being\n              // added, we should skip any logic now since `flip()` has already done its\n              // work.\n              // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n\n              if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                return [2, {}];\n              }\n\n              side = getSide(placement);\n              isBasePlacement = getSide(initialPlacement) === initialPlacement;\n              return [4, platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)];\n\n            case 1:\n              rtl = _state.sent();\n              fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n\n              if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== \"none\") {\n                ;\n\n                (_fallbackPlacements = fallbackPlacements).push.apply(_fallbackPlacements, _to_consumable_array(getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl)));\n              }\n\n              placements = [initialPlacement].concat(_to_consumable_array(fallbackPlacements));\n              return [4, detectOverflow(state, detectOverflowOptions)];\n\n            case 2:\n              overflow = _state.sent();\n              overflows = [];\n              overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n\n              if (checkMainAxis) {\n                overflows.push(overflow[side]);\n              }\n\n              if (checkCrossAxis) {\n                sides = getAlignmentSides(placement, rects, rtl);\n                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n              }\n\n              overflowsData = _to_consumable_array(overflowsData).concat([{\n                placement: placement,\n                overflows: overflows\n              }]); // One or more sides is overflowing.\n\n              if (!overflows.every(function (side) {\n                return side <= 0;\n              })) {\n                ;\n                nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                nextPlacement = placements[nextIndex];\n\n                if (nextPlacement) {\n                  // Try next placement and re-run the lifecycle.\n                  return [2, {\n                    data: {\n                      index: nextIndex,\n                      overflows: overflowsData\n                    },\n                    reset: {\n                      placement: nextPlacement\n                    }\n                  }];\n                } // First, find the candidates that fit on the mainAxis side of overflow,\n                // then find the placement that fits the best on the main crossAxis side.\n\n\n                resetPlacement = (_overflowsData$filter = overflowsData.filter(function (d) {\n                  return d.overflows[0] <= 0;\n                }).sort(function (a, b) {\n                  return a.overflows[1] - b.overflows[1];\n                })[0]) == null ? void 0 : _overflowsData$filter.placement; // Otherwise fallback.\n\n                if (!resetPlacement) {\n                  switch (fallbackStrategy) {\n                    case \"bestFit\":\n                      {\n                        ;\n                        placement1 = (_overflowsData$map$so = overflowsData.map(function (d) {\n                          return [d.placement, d.overflows.filter(function (overflow) {\n                            return overflow > 0;\n                          }).reduce(function (acc, overflow) {\n                            return acc + overflow;\n                          }, 0)];\n                        }).sort(function (a, b) {\n                          return a[1] - b[1];\n                        })[0]) == null ? void 0 : _overflowsData$map$so[0];\n\n                        if (placement1) {\n                          resetPlacement = placement1;\n                        }\n\n                        break;\n                      }\n\n                    case \"initialPlacement\":\n                      resetPlacement = initialPlacement;\n                      break;\n                  }\n                }\n\n                if (placement !== resetPlacement) {\n                  return [2, {\n                    reset: {\n                      placement: resetPlacement\n                    }\n                  }];\n                }\n              }\n\n              return [2, {}];\n          }\n        });\n      })();\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\n\n\nvar hide = function hide(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: \"hide\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var rects, _evaluate, _evaluate_strategy, strategy, detectOverflowOptions, overflow, offsets, overflow1, offsets1;\n\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              rects = state.rects;\n              _evaluate = evaluate(options, state), _evaluate_strategy = _evaluate.strategy, strategy = _evaluate_strategy === void 0 ? \"referenceHidden\" : _evaluate_strategy, detectOverflowOptions = _object_without_properties(_evaluate, [\"strategy\"]);\n\n              switch (strategy) {\n                case \"referenceHidden\":\n                  return [3, 1];\n\n                case \"escaped\":\n                  return [3, 3];\n              }\n\n              return [3, 5];\n\n            case 1:\n              return [4, detectOverflow(state, _object_spread_props(_object_spread({}, detectOverflowOptions), {\n                elementContext: \"reference\"\n              }))];\n\n            case 2:\n              overflow = _state.sent();\n              offsets = getSideOffsets(overflow, rects.reference);\n              return [2, {\n                data: {\n                  referenceHiddenOffsets: offsets,\n                  referenceHidden: isAnySideFullyClipped(offsets)\n                }\n              }];\n\n            case 3:\n              return [4, detectOverflow(state, _object_spread_props(_object_spread({}, detectOverflowOptions), {\n                altBoundary: true\n              }))];\n\n            case 4:\n              overflow1 = _state.sent();\n              offsets1 = getSideOffsets(overflow1, rects.floating);\n              return [2, {\n                data: {\n                  escapedOffsets: offsets1,\n                  escaped: isAnySideFullyClipped(offsets1)\n                }\n              }];\n\n            case 5:\n              {\n                return [2, {}];\n              }\n              _state.label = 6;\n\n            case 6:\n              return [2];\n          }\n        });\n      })();\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  var minX = min.apply(void 0, _to_consumable_array(rects.map(function (rect) {\n    return rect.left;\n  })));\n  var minY = min.apply(void 0, _to_consumable_array(rects.map(function (rect) {\n    return rect.top;\n  })));\n  var maxX = max.apply(void 0, _to_consumable_array(rects.map(function (rect) {\n    return rect.right;\n  })));\n  var maxY = max.apply(void 0, _to_consumable_array(rects.map(function (rect) {\n    return rect.bottom;\n  })));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\n\nfunction getRectsByLine(rects) {\n  var sortedRects = rects.slice().sort(function (a, b) {\n    return a.y - b.y;\n  });\n  var groups = [];\n  var prevRect = null;\n\n  for (var i = 0; i < sortedRects.length; i++) {\n    var rect = sortedRects[i];\n\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n\n    prevRect = rect;\n  }\n\n  return groups.map(function (rect) {\n    return rectToClientRect(getBoundingRect(rect));\n  });\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\n\n\nvar inline = function inline(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: \"inline\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var placement, elements, rects, platform, strategy, _evaluate, _evaluate_padding, padding, x, y, nativeClientRects, _, clientRects, fallback, paddingObject, resetRects;\n\n        function getBoundingClientRect() {\n          // There are two rects and they are disjoined.\n          if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n            // Find the first rect in which the point is fully inside.\n            return clientRects.find(function (rect) {\n              return x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom;\n            }) || fallback;\n          } // There are 2 or more connected rects.\n\n\n          if (clientRects.length >= 2) {\n            if (getSideAxis(placement) === \"y\") {\n              var firstRect = clientRects[0];\n              var lastRect = clientRects[clientRects.length - 1];\n              var isTop = getSide(placement) === \"top\";\n              var top = firstRect.top;\n              var bottom = lastRect.bottom;\n              var left = isTop ? firstRect.left : lastRect.left;\n              var right = isTop ? firstRect.right : lastRect.right;\n              var width = right - left;\n              var height = bottom - top;\n              return {\n                top: top,\n                bottom: bottom,\n                left: left,\n                right: right,\n                width: width,\n                height: height,\n                x: left,\n                y: top\n              };\n            }\n\n            var isLeftSide = getSide(placement) === \"left\";\n            var maxRight = max.apply(void 0, _to_consumable_array(clientRects.map(function (rect) {\n              return rect.right;\n            })));\n            var minLeft = min.apply(void 0, _to_consumable_array(clientRects.map(function (rect) {\n              return rect.left;\n            })));\n            var measureRects = clientRects.filter(function (rect) {\n              return isLeftSide ? rect.left === minLeft : rect.right === maxRight;\n            });\n            var top1 = measureRects[0].top;\n            var bottom1 = measureRects[measureRects.length - 1].bottom;\n            var left1 = minLeft;\n            var right1 = maxRight;\n            var width1 = right1 - left1;\n            var height1 = bottom1 - top1;\n            return {\n              top: top1,\n              bottom: bottom1,\n              left: left1,\n              right: right1,\n              width: width1,\n              height: height1,\n              x: left1,\n              y: top1\n            };\n          }\n\n          return fallback;\n        }\n\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              placement = state.placement, elements = state.elements, rects = state.rects, platform = state.platform, strategy = state.strategy; // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n              // ClientRect's bounds, despite the event listener being triggered. A\n              // padding of 2 seems to handle this issue.\n\n              _evaluate = evaluate(options, state), _evaluate_padding = _evaluate.padding, padding = _evaluate_padding === void 0 ? 2 : _evaluate_padding, x = _evaluate.x, y = _evaluate.y;\n              _ = Array.from;\n              return [4, platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)];\n\n            case 1:\n              nativeClientRects = _.apply(Array, [_state.sent() || []]);\n              clientRects = getRectsByLine(nativeClientRects);\n              fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n              paddingObject = getPaddingObject(padding);\n              return [4, platform.getElementRects({\n                reference: {\n                  getBoundingClientRect: getBoundingClientRect\n                },\n                floating: elements.floating,\n                strategy: strategy\n              })];\n\n            case 2:\n              resetRects = _state.sent();\n\n              if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                return [2, {\n                  reset: {\n                    rects: resetRects\n                  }\n                }];\n              }\n\n              return [2, {}];\n          }\n        });\n      })();\n    }\n  };\n};\n\nfunction convertValueToCoords(state, options) {\n  return _convertValueToCoords.apply(this, arguments);\n}\n\nfunction _convertValueToCoords() {\n  _convertValueToCoords = // For type backwards-compatibility, the `OffsetOptions` type was also\n  // Derivable.\n  _async_to_generator(function (state, options) {\n    var placement, platform, elements, rtl, side, alignment, isVertical, mainAxisMulti, crossAxisMulti, rawValue, _ref, mainAxis, crossAxis, alignmentAxis;\n\n    return _ts_generator(this, function (_state) {\n      switch (_state.label) {\n        case 0:\n          placement = state.placement, platform = state.platform, elements = state.elements;\n          return [4, platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)];\n\n        case 1:\n          rtl = _state.sent();\n          side = getSide(placement);\n          alignment = getAlignment(placement);\n          isVertical = getSideAxis(placement) === \"y\";\n          mainAxisMulti = [\"left\", \"top\"].includes(side) ? -1 : 1;\n          crossAxisMulti = rtl && isVertical ? -1 : 1;\n          rawValue = evaluate(options, state); // eslint-disable-next-line prefer-const\n\n          _ref = typeof rawValue === \"number\" ? {\n            mainAxis: rawValue,\n            crossAxis: 0,\n            alignmentAxis: null\n          } : _object_spread({\n            mainAxis: 0,\n            crossAxis: 0,\n            alignmentAxis: null\n          }, rawValue), mainAxis = _ref.mainAxis, crossAxis = _ref.crossAxis, alignmentAxis = _ref.alignmentAxis;\n\n          if (alignment && typeof alignmentAxis === \"number\") {\n            crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n          }\n\n          return [2, isVertical ? {\n            x: crossAxis * crossAxisMulti,\n            y: mainAxis * mainAxisMulti\n          } : {\n            x: mainAxis * mainAxisMulti,\n            y: crossAxis * crossAxisMulti\n          }];\n      }\n    });\n  });\n  return _convertValueToCoords.apply(this, arguments);\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\n\n\nvar offset = function offset(options) {\n  if (options === void 0) {\n    options = 0;\n  }\n\n  return {\n    name: \"offset\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var x, y, diffCoords;\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              x = state.x, y = state.y;\n              return [4, convertValueToCoords(state, options)];\n\n            case 1:\n              diffCoords = _state.sent();\n              return [2, {\n                x: x + diffCoords.x,\n                y: y + diffCoords.y,\n                data: diffCoords\n              }];\n          }\n        });\n      })();\n    }\n  };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\n\n\nvar shift = function shift(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: \"shift\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var x, y, placement, _evaluate, tmp, checkMainAxis, tmp1, checkCrossAxis, _evaluate_limiter, limiter, detectOverflowOptions, coords, overflow, crossAxis, mainAxis, mainAxisCoord, crossAxisCoord, minSide, maxSide, min, max, minSide1, maxSide1, min1, max1, _obj, limitedCoords;\n\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              x = state.x, y = state.y, placement = state.placement;\n              _evaluate = evaluate(options, state), tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? false : tmp1, _evaluate_limiter = _evaluate.limiter, limiter = _evaluate_limiter === void 0 ? {\n                fn: function (_ref) {\n                  var x = _ref.x,\n                      y = _ref.y;\n                  return {\n                    x: x,\n                    y: y\n                  };\n                }\n              } : _evaluate_limiter, detectOverflowOptions = _object_without_properties(_evaluate, [\"mainAxis\", \"crossAxis\", \"limiter\"]);\n              coords = {\n                x: x,\n                y: y\n              };\n              return [4, detectOverflow(state, detectOverflowOptions)];\n\n            case 1:\n              overflow = _state.sent();\n              crossAxis = getSideAxis(getSide(placement));\n              mainAxis = getOppositeAxis(crossAxis);\n              mainAxisCoord = coords[mainAxis];\n              crossAxisCoord = coords[crossAxis];\n\n              if (checkMainAxis) {\n                minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                min = mainAxisCoord + overflow[minSide];\n                max = mainAxisCoord - overflow[maxSide];\n                mainAxisCoord = clamp(min, mainAxisCoord, max);\n              }\n\n              if (checkCrossAxis) {\n                minSide1 = crossAxis === \"y\" ? \"top\" : \"left\";\n                maxSide1 = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                min1 = crossAxisCoord + overflow[minSide1];\n                max1 = crossAxisCoord - overflow[maxSide1];\n                crossAxisCoord = clamp(min1, crossAxisCoord, max1);\n              }\n\n              limitedCoords = limiter.fn(_object_spread_props(_object_spread({}, state), (_obj = {}, _define_property(_obj, mainAxis, mainAxisCoord), _define_property(_obj, crossAxis, crossAxisCoord), _obj)));\n              return [2, _object_spread_props(_object_spread({}, limitedCoords), {\n                data: {\n                  x: limitedCoords.x - x,\n                  y: limitedCoords.y - y\n                }\n              })];\n          }\n        });\n      })();\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\n\n\nvar limitShift = function limitShift(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    options: options,\n    fn: function fn(state) {\n      var x = state.x,\n          y = state.y,\n          placement = state.placement,\n          rects = state.rects,\n          middlewareData = state.middlewareData;\n\n      var _evaluate = evaluate(options, state),\n          _evaluate_offset = _evaluate.offset,\n          offset = _evaluate_offset === void 0 ? 0 : _evaluate_offset,\n          tmp = _evaluate.mainAxis,\n          checkMainAxis = tmp === void 0 ? true : tmp,\n          tmp1 = _evaluate.crossAxis,\n          checkCrossAxis = tmp1 === void 0 ? true : tmp1;\n\n      var coords = {\n        x: x,\n        y: y\n      };\n      var crossAxis = getSideAxis(placement);\n      var mainAxis = getOppositeAxis(crossAxis);\n      var mainAxisCoord = coords[mainAxis];\n      var crossAxisCoord = coords[crossAxis];\n      var rawOffset = evaluate(offset, state);\n      var computedOffset = typeof rawOffset === \"number\" ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : _object_spread({\n        mainAxis: 0,\n        crossAxis: 0\n      }, rawOffset);\n\n      if (checkMainAxis) {\n        var len = mainAxis === \"y\" ? \"height\" : \"width\";\n        var limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        var limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n\n        var len1 = mainAxis === \"y\" ? \"width\" : \"height\";\n        var isOriginSide = [\"top\", \"left\"].includes(getSide(placement));\n        var limitMin1 = rects.reference[crossAxis] - rects.floating[len1] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        var limitMax1 = rects.reference[crossAxis] + rects.reference[len1] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n\n        if (crossAxisCoord < limitMin1) {\n          crossAxisCoord = limitMin1;\n        } else if (crossAxisCoord > limitMax1) {\n          crossAxisCoord = limitMax1;\n        }\n      }\n\n      var _obj;\n\n      return _obj = {}, _define_property(_obj, mainAxis, mainAxisCoord), _define_property(_obj, crossAxis, crossAxisCoord), _obj;\n    }\n  };\n};\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\n\n\nvar size = function size(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  return {\n    name: \"size\",\n    options: options,\n    fn: function fn(state) {\n      return _async_to_generator(function () {\n        var placement, rects, platform, elements, _evaluate, _evaluate_apply, apply, detectOverflowOptions, overflow, side, alignment, isYAxis, _rects_floating, width, height, heightSide, widthSide, overflowAvailableHeight, overflowAvailableWidth, noShift, availableHeight, availableWidth, maximumClippingWidth, maximumClippingHeight, xMin, xMax, yMin, yMax, nextDimensions;\n\n        return _ts_generator(this, function (_state) {\n          switch (_state.label) {\n            case 0:\n              placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements;\n              _evaluate = evaluate(options, state), _evaluate_apply = _evaluate.apply, apply = _evaluate_apply === void 0 ? function () {} : _evaluate_apply, detectOverflowOptions = _object_without_properties(_evaluate, [\"apply\"]);\n              return [4, detectOverflow(state, detectOverflowOptions)];\n\n            case 1:\n              overflow = _state.sent();\n              side = getSide(placement);\n              alignment = getAlignment(placement);\n              isYAxis = getSideAxis(placement) === \"y\";\n              _rects_floating = rects.floating, width = _rects_floating.width, height = _rects_floating.height;\n              if (!(side === \"top\" || side === \"bottom\")) return [3, 3];\n              heightSide = side;\n              return [4, platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)];\n\n            case 2:\n              widthSide = alignment === (_state.sent() ? \"start\" : \"end\") ? \"left\" : \"right\";\n              return [3, 4];\n\n            case 3:\n              widthSide = side;\n              heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n              _state.label = 4;\n\n            case 4:\n              overflowAvailableHeight = height - overflow[heightSide];\n              overflowAvailableWidth = width - overflow[widthSide];\n              noShift = !state.middlewareData.shift;\n              availableHeight = overflowAvailableHeight;\n              availableWidth = overflowAvailableWidth;\n\n              if (isYAxis) {\n                maximumClippingWidth = width - overflow.left - overflow.right;\n                availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n              } else {\n                maximumClippingHeight = height - overflow.top - overflow.bottom;\n                availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n              }\n\n              if (noShift && !alignment) {\n                xMin = max(overflow.left, 0);\n                xMax = max(overflow.right, 0);\n                yMin = max(overflow.top, 0);\n                yMax = max(overflow.bottom, 0);\n\n                if (isYAxis) {\n                  availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n                } else {\n                  availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n                }\n              }\n\n              return [4, apply(_object_spread_props(_object_spread({}, state), {\n                availableWidth: availableWidth,\n                availableHeight: availableHeight\n              }))];\n\n            case 5:\n              _state.sent();\n\n              return [4, platform.getDimensions(elements.floating)];\n\n            case 6:\n              nextDimensions = _state.sent();\n\n              if (width !== nextDimensions.width || height !== nextDimensions.height) {\n                return [2, {\n                  reset: {\n                    rects: true\n                  }\n                }];\n              }\n\n              return [2, {}];\n          }\n        });\n      })();\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };","map":{"version":3,"names":["_","_async_to_generator","_define_property","_object_spread","_object_spread_props","_object_without_properties","_to_consumable_array","_ts_generator","getSideAxis","getAlignmentAxis","getAxisLength","getSide","getAlignment","evaluate","getPaddingObject","rectToClientRect","min","clamp","placements","getAlignmentSides","getOppositeAlignmentPlacement","getOppositePlacement","getExpandedPlacements","getOppositeAxisPlacements","sides","max","getOppositeAxis","computeCoordsFromPlacement","_ref","placement","rtl","reference","floating","sideAxis","alignmentAxis","alignLength","side","isVertical","commonX","x","width","commonY","y","height","commonAlign","coords","computePosition","config","_config_placement","_config_strategy","strategy","_config_middleware","middleware","platform","validMiddleware","rects","_computeCoordsFromPlacement","statefulPlacement","middlewareData","resetCount","i","_validMiddleware_i","name","fn","nextX","nextY","data","reset","_tmp","ref","_state","label","filter","Boolean","isRTL","sent","getElementRects","length","initialPlacement","elements","apply","arguments","detectOverflow","state","options","_detectOverflow","_await$platform$isEle","_evaluate","_evaluate_boundary","boundary","_evaluate_rootBoundary","rootBoundary","_evaluate_elementContext","elementContext","_evaluate_altBoundary","altBoundary","_evaluate_padding","padding","paddingObject","altContext","element","clippingClientRect","_tmp1","_tmp2","rect","offsetParent","offsetScale","_tmp3","elementClientRect","_tmp4","getClippingRect","isElement","contextElement","getDocumentElement","getOffsetParent","getScale","convertOffsetParentRelativeRectToViewportRelativeRect","top","bottom","left","right","arrow","_ref_padding","axis","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","offset","shouldAddOffset","alignmentOffset","_obj","_obj1","getDimensions","getPlacementList","alignment","autoAlignment","allowedPlacements","allowedPlacementsSortedByAlignment","concat","autoPlacement","_middlewareData$autoP","_middlewareData$autoP2","_placementsThatFitOnE","_evaluate_crossAxis","crossAxis","_evaluate_allowedPlacements","_evaluate_autoAlignment","detectOverflowOptions","placements$1","overflow","currentIndex","currentPlacement","alignmentSides","currentOverflows","allOverflows","nextPlacement","placementsSortedByMostSpace","placementsThatFitOnEachSide","resetPlacement","undefined","index","overflows","map","d","slice","reduce","acc","v","sort","a","b","every","flip","_middlewareData$arrow","_middlewareData$flip","tmp","checkMainAxis","tmp1","checkCrossAxis","specifiedFallbackPlacements","_evaluate_fallbackStrategy","fallbackStrategy","_evaluate_fallbackAxisSideDirection","fallbackAxisSideDirection","_evaluate_flipAlignment","flipAlignment","isBasePlacement","fallbackPlacements","_fallbackPlacements","overflowsData","_middlewareData$flip2","_overflowsData$filter","nextIndex","_overflowsData$map$so","placement1","mainAxis","push","getSideOffsets","isAnySideFullyClipped","some","hide","_evaluate_strategy","offsets","overflow1","offsets1","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","getBoundingRect","minX","minY","maxX","maxY","getRectsByLine","sortedRects","groups","prevRect","inline","nativeClientRects","clientRects","fallback","resetRects","getBoundingClientRect","find","firstRect","lastRect","isTop","isLeftSide","maxRight","minLeft","measureRects","top1","bottom1","left1","right1","width1","height1","Array","from","getClientRects","convertValueToCoords","_convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","includes","diffCoords","shift","_evaluate_limiter","limiter","mainAxisCoord","crossAxisCoord","minSide","maxSide","minSide1","maxSide1","min1","max1","limitedCoords","limitShift","_evaluate_offset","rawOffset","computedOffset","len","limitMin","limitMax","_middlewareData$offse","_middlewareData$offse2","len1","isOriginSide","limitMin1","limitMax1","size","_evaluate_apply","_rects_floating","heightSide","widthSide","overflowAvailableHeight","overflowAvailableWidth","noShift","availableHeight","availableWidth","maximumClippingWidth","maximumClippingHeight","xMin","xMax","yMin","yMax","nextDimensions"],"sources":["C:/Users/kulag/vk/Ability/node_modules/@vkontakte/vkui-floating-ui/core/dist/floating-ui.core.esm.js"],"sourcesContent":["import { _ as _async_to_generator } from \"@swc/helpers/_/_async_to_generator\";\nimport { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\nimport { _ as _ts_generator } from \"@swc/helpers/_/_ts_generator\";\nimport { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '../../utils/dist/floating-ui.utils.esm.js';\nexport { rectToClientRect } from '../../utils/dist/floating-ui.utils.esm.js';\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n    var reference = _ref.reference, floating = _ref.floating;\n    var sideAxis = getSideAxis(placement);\n    var alignmentAxis = getAlignmentAxis(placement);\n    var alignLength = getAxisLength(alignmentAxis);\n    var side = getSide(placement);\n    var isVertical = sideAxis === \"y\";\n    var commonX = reference.x + reference.width / 2 - floating.width / 2;\n    var commonY = reference.y + reference.height / 2 - floating.height / 2;\n    var commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n    var coords;\n    switch(side){\n        case \"top\":\n            coords = {\n                x: commonX,\n                y: reference.y - floating.height\n            };\n            break;\n        case \"bottom\":\n            coords = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case \"right\":\n            coords = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case \"left\":\n            coords = {\n                x: reference.x - floating.width,\n                y: commonY\n            };\n            break;\n        default:\n            coords = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    switch(getAlignment(placement)){\n        case \"start\":\n            coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n        case \"end\":\n            coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n            break;\n    }\n    return coords;\n}\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */ var computePosition = function() {\n    var _ref = _async_to_generator(function(reference, floating, config) {\n        var _config_placement, placement, _config_strategy, strategy, _config_middleware, middleware, platform, validMiddleware, rtl, rects, _computeCoordsFromPlacement, x, y, statefulPlacement, middlewareData, resetCount, i, _validMiddleware_i, name, fn, _ref, nextX, nextY, data, reset, _tmp, ref;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    _config_placement = config.placement, placement = _config_placement === void 0 ? \"bottom\" : _config_placement, _config_strategy = config.strategy, strategy = _config_strategy === void 0 ? \"absolute\" : _config_strategy, _config_middleware = config.middleware, middleware = _config_middleware === void 0 ? [] : _config_middleware, platform = config.platform;\n                    validMiddleware = middleware.filter(Boolean);\n                    return [\n                        4,\n                        platform.isRTL == null ? void 0 : platform.isRTL(floating)\n                    ];\n                case 1:\n                    rtl = _state.sent();\n                    return [\n                        4,\n                        platform.getElementRects({\n                            reference: reference,\n                            floating: floating,\n                            strategy: strategy\n                        })\n                    ];\n                case 2:\n                    rects = _state.sent();\n                    _computeCoordsFromPlacement = computeCoordsFromPlacement(rects, placement, rtl), x = _computeCoordsFromPlacement.x, y = _computeCoordsFromPlacement.y;\n                    statefulPlacement = placement;\n                    middlewareData = {};\n                    resetCount = 0;\n                    i = 0;\n                    _state.label = 3;\n                case 3:\n                    if (!(i < validMiddleware.length)) return [\n                        3,\n                        11\n                    ];\n                    _validMiddleware_i = validMiddleware[i], name = _validMiddleware_i.name, fn = _validMiddleware_i.fn;\n                    return [\n                        4,\n                        fn({\n                            x: x,\n                            y: y,\n                            initialPlacement: placement,\n                            placement: statefulPlacement,\n                            strategy: strategy,\n                            middlewareData: middlewareData,\n                            rects: rects,\n                            platform: platform,\n                            elements: {\n                                reference: reference,\n                                floating: floating\n                            }\n                        })\n                    ];\n                case 4:\n                    _ref = _state.sent(), nextX = _ref.x, nextY = _ref.y, data = _ref.data, reset = _ref.reset;\n                    x = nextX != null ? nextX : x;\n                    y = nextY != null ? nextY : y;\n                    middlewareData = _object_spread_props(_object_spread({}, middlewareData), _define_property({}, name, _object_spread({}, middlewareData[name], data)));\n                    if (!(reset && resetCount <= 50)) return [\n                        3,\n                        10\n                    ];\n                    resetCount++;\n                    if (!(typeof reset === \"object\")) return [\n                        3,\n                        9\n                    ];\n                    if (reset.placement) {\n                        statefulPlacement = reset.placement;\n                    }\n                    if (!reset.rects) return [\n                        3,\n                        8\n                    ];\n                    if (!(reset.rects === true)) return [\n                        3,\n                        6\n                    ];\n                    return [\n                        4,\n                        platform.getElementRects({\n                            reference: reference,\n                            floating: floating,\n                            strategy: strategy\n                        })\n                    ];\n                case 5:\n                    _tmp = _state.sent();\n                    return [\n                        3,\n                        7\n                    ];\n                case 6:\n                    _tmp = reset.rects;\n                    _state.label = 7;\n                case 7:\n                    rects = _tmp;\n                    _state.label = 8;\n                case 8:\n                    ref = computeCoordsFromPlacement(rects, statefulPlacement, rtl), x = ref.x, y = ref.y, ref;\n                    _state.label = 9;\n                case 9:\n                    i = -1;\n                    return [\n                        3,\n                        10\n                    ];\n                case 10:\n                    i++;\n                    return [\n                        3,\n                        3\n                    ];\n                case 11:\n                    return [\n                        2,\n                        {\n                            x: x,\n                            y: y,\n                            placement: statefulPlacement,\n                            strategy: strategy,\n                            middlewareData: middlewareData\n                        }\n                    ];\n            }\n        });\n    });\n    return function computePosition(reference, floating, config) {\n        return _ref.apply(this, arguments);\n    };\n}();\nfunction detectOverflow(state, options) {\n    return _detectOverflow.apply(this, arguments);\n}\nfunction _detectOverflow() {\n    _detectOverflow = /**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */ _async_to_generator(function(state, options) {\n        var _await$platform$isEle, x, y, platform, rects, elements, strategy, _evaluate, _evaluate_boundary, boundary, _evaluate_rootBoundary, rootBoundary, _evaluate_elementContext, elementContext, _evaluate_altBoundary, altBoundary, _evaluate_padding, padding, paddingObject, altContext, element, clippingClientRect, _, _tmp, _tmp1, _tmp2, rect, offsetParent, offsetScale, _tmp3, elementClientRect, _tmp4;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    if (options === void 0) {\n                        options = {};\n                    }\n                    x = state.x, y = state.y, platform = state.platform, rects = state.rects, elements = state.elements, strategy = state.strategy;\n                    _evaluate = evaluate(options, state), _evaluate_boundary = _evaluate.boundary, boundary = _evaluate_boundary === void 0 ? \"clippingAncestors\" : _evaluate_boundary, _evaluate_rootBoundary = _evaluate.rootBoundary, rootBoundary = _evaluate_rootBoundary === void 0 ? \"viewport\" : _evaluate_rootBoundary, _evaluate_elementContext = _evaluate.elementContext, elementContext = _evaluate_elementContext === void 0 ? \"floating\" : _evaluate_elementContext, _evaluate_altBoundary = _evaluate.altBoundary, altBoundary = _evaluate_altBoundary === void 0 ? false : _evaluate_altBoundary, _evaluate_padding = _evaluate.padding, padding = _evaluate_padding === void 0 ? 0 : _evaluate_padding;\n                    paddingObject = getPaddingObject(padding);\n                    altContext = elementContext === \"floating\" ? \"reference\" : \"floating\";\n                    element = elements[altBoundary ? altContext : elementContext];\n                    _ = platform.getClippingRect;\n                    _tmp = {};\n                    return [\n                        4,\n                        platform.isElement == null ? void 0 : platform.isElement(element)\n                    ];\n                case 1:\n                    if (!((_await$platform$isEle = _state.sent()) != null ? _await$platform$isEle : true)) return [\n                        3,\n                        2\n                    ];\n                    _tmp1 = element;\n                    return [\n                        3,\n                        5\n                    ];\n                case 2:\n                    _tmp2 = element.contextElement;\n                    if (_tmp2) return [\n                        3,\n                        4\n                    ];\n                    return [\n                        4,\n                        platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)\n                    ];\n                case 3:\n                    _tmp2 = _state.sent();\n                    _state.label = 4;\n                case 4:\n                    _tmp1 = _tmp2;\n                    _state.label = 5;\n                case 5:\n                    return [\n                        4,\n                        _.apply(platform, [\n                            (_tmp.element = _tmp1, _tmp.boundary = boundary, _tmp.rootBoundary = rootBoundary, _tmp.strategy = strategy, _tmp)\n                        ])\n                    ];\n                case 6:\n                    clippingClientRect = rectToClientRect.apply(void 0, [\n                        _state.sent()\n                    ]);\n                    rect = elementContext === \"floating\" ? _object_spread_props(_object_spread({}, rects.floating), {\n                        x: x,\n                        y: y\n                    }) : rects.reference;\n                    return [\n                        4,\n                        platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)\n                    ];\n                case 7:\n                    offsetParent = _state.sent();\n                    return [\n                        4,\n                        platform.isElement == null ? void 0 : platform.isElement(offsetParent)\n                    ];\n                case 8:\n                    if (!_state.sent()) return [\n                        3,\n                        10\n                    ];\n                    return [\n                        4,\n                        platform.getScale == null ? void 0 : platform.getScale(offsetParent)\n                    ];\n                case 9:\n                    _tmp3 = _state.sent() || {\n                        x: 1,\n                        y: 1\n                    };\n                    return [\n                        3,\n                        11\n                    ];\n                case 10:\n                    _tmp3 = {\n                        x: 1,\n                        y: 1\n                    };\n                    _state.label = 11;\n                case 11:\n                    offsetScale = _tmp3;\n                    if (!platform.convertOffsetParentRelativeRectToViewportRelativeRect) return [\n                        3,\n                        13\n                    ];\n                    return [\n                        4,\n                        platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n                            rect: rect,\n                            offsetParent: offsetParent,\n                            strategy: strategy\n                        })\n                    ];\n                case 12:\n                    _tmp4 = _state.sent();\n                    return [\n                        3,\n                        14\n                    ];\n                case 13:\n                    _tmp4 = rect;\n                    _state.label = 14;\n                case 14:\n                    elementClientRect = rectToClientRect.apply(void 0, [\n                        _tmp4\n                    ]);\n                    return [\n                        2,\n                        {\n                            top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n                            bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n                            left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n                            right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n                        }\n                    ];\n            }\n        });\n    });\n    return _detectOverflow.apply(this, arguments);\n}\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */ var arrow = function(options) {\n    return {\n        name: \"arrow\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var x, y, placement, rects, platform, elements, middlewareData, _ref, element, _ref_padding, padding, paddingObject, coords, axis, length, arrowDimensions, isYAxis, minProp, maxProp, clientProp, endDiff, startDiff, arrowOffsetParent, clientSize, _tmp, centerToReference, largestPossiblePadding, minPadding, maxPadding, min$1, max, center, offset, shouldAddOffset, alignmentOffset, _obj, _obj1;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            x = state.x, y = state.y, placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements, middlewareData = state.middlewareData;\n                            // Since `element` is required, we don't Partial<> the type.\n                            _ref = evaluate(options, state) || {}, element = _ref.element, _ref_padding = _ref.padding, padding = _ref_padding === void 0 ? 0 : _ref_padding;\n                            if (element == null) {\n                                return [\n                                    2,\n                                    {}\n                                ];\n                            }\n                            paddingObject = getPaddingObject(padding);\n                            coords = {\n                                x: x,\n                                y: y\n                            };\n                            axis = getAlignmentAxis(placement);\n                            length = getAxisLength(axis);\n                            return [\n                                4,\n                                platform.getDimensions(element)\n                            ];\n                        case 1:\n                            arrowDimensions = _state.sent();\n                            isYAxis = axis === \"y\";\n                            minProp = isYAxis ? \"top\" : \"left\";\n                            maxProp = isYAxis ? \"bottom\" : \"right\";\n                            clientProp = isYAxis ? \"clientHeight\" : \"clientWidth\";\n                            endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n                            startDiff = coords[axis] - rects.reference[axis];\n                            return [\n                                4,\n                                platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element)\n                            ];\n                        case 2:\n                            arrowOffsetParent = _state.sent();\n                            clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n                            _tmp = !clientSize;\n                            if (_tmp) return [\n                                3,\n                                4\n                            ];\n                            return [\n                                4,\n                                platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)\n                            ];\n                        case 3:\n                            _tmp = !_state.sent();\n                            _state.label = 4;\n                        case 4:\n                            // DOM platform can return `window` as the `offsetParent`.\n                            if (_tmp) {\n                                clientSize = elements.floating[clientProp] || rects.floating[length];\n                            }\n                            centerToReference = endDiff / 2 - startDiff / 2;\n                            // If the padding is large enough that it causes the arrow to no longer be\n                            // centered, modify the padding so that it is centered.\n                            largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n                            minPadding = min(paddingObject[minProp], largestPossiblePadding);\n                            maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n                            // Make sure the arrow doesn't overflow the floating element if the center\n                            // point is outside the floating element's bounds.\n                            min$1 = minPadding;\n                            max = clientSize - arrowDimensions[length] - maxPadding;\n                            center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n                            offset = clamp(min$1, center, max);\n                            // If the reference is small enough that the arrow's padding causes it to\n                            // to point to nothing for an aligned placement, adjust the offset of the\n                            // floating element itself. To ensure `shift()` continues to take action,\n                            // a single reset is performed when this is true.\n                            shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n                            alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n                            return [\n                                2,\n                                (_obj1 = {}, _define_property(_obj1, axis, coords[axis] + alignmentOffset), _define_property(_obj1, \"data\", _object_spread((_obj = {}, _define_property(_obj, axis, offset), _define_property(_obj, \"centerOffset\", center - offset - alignmentOffset), _obj), shouldAddOffset && {\n                                    alignmentOffset: alignmentOffset\n                                })), _define_property(_obj1, \"reset\", shouldAddOffset), _obj1)\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n    var allowedPlacementsSortedByAlignment = alignment ? _to_consumable_array(allowedPlacements.filter(function(placement) {\n        return getAlignment(placement) === alignment;\n    })).concat(_to_consumable_array(allowedPlacements.filter(function(placement) {\n        return getAlignment(placement) !== alignment;\n    }))) : allowedPlacements.filter(function(placement) {\n        return getSide(placement) === placement;\n    });\n    return allowedPlacementsSortedByAlignment.filter(function(placement) {\n        if (alignment) {\n            return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n        }\n        return true;\n    });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */ var autoPlacement = function autoPlacement(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"autoPlacement\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE, rects, middlewareData, placement, platform, elements, _evaluate, _evaluate_crossAxis, crossAxis, alignment, _evaluate_allowedPlacements, allowedPlacements, _evaluate_autoAlignment, autoAlignment, detectOverflowOptions, placements$1, overflow, currentIndex, currentPlacement, alignmentSides, _tmp, currentOverflows, allOverflows, nextPlacement, placementsSortedByMostSpace, placementsThatFitOnEachSide, resetPlacement;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            rects = state.rects, middlewareData = state.middlewareData, placement = state.placement, platform = state.platform, elements = state.elements;\n                            _evaluate = evaluate(options, state), _evaluate_crossAxis = _evaluate.crossAxis, crossAxis = _evaluate_crossAxis === void 0 ? false : _evaluate_crossAxis, alignment = _evaluate.alignment, _evaluate_allowedPlacements = _evaluate.allowedPlacements, allowedPlacements = _evaluate_allowedPlacements === void 0 ? placements : _evaluate_allowedPlacements, _evaluate_autoAlignment = _evaluate.autoAlignment, autoAlignment = _evaluate_autoAlignment === void 0 ? true : _evaluate_autoAlignment, detectOverflowOptions = _object_without_properties(_evaluate, [\n                                \"crossAxis\",\n                                \"alignment\",\n                                \"allowedPlacements\",\n                                \"autoAlignment\"\n                            ]);\n                            placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n                            return [\n                                4,\n                                detectOverflow(state, detectOverflowOptions)\n                            ];\n                        case 1:\n                            overflow = _state.sent();\n                            currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n                            currentPlacement = placements$1[currentIndex];\n                            if (currentPlacement == null) {\n                                return [\n                                    2,\n                                    {}\n                                ];\n                            }\n                            _tmp = [\n                                currentPlacement,\n                                rects\n                            ];\n                            return [\n                                4,\n                                platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)\n                            ];\n                        case 2:\n                            alignmentSides = getAlignmentSides.apply(void 0, _tmp.concat([\n                                _state.sent()\n                            ]));\n                            // Make `computeCoords` start from the right place.\n                            if (placement !== currentPlacement) {\n                                return [\n                                    2,\n                                    {\n                                        reset: {\n                                            placement: placements$1[0]\n                                        }\n                                    }\n                                ];\n                            }\n                            currentOverflows = [\n                                overflow[getSide(currentPlacement)],\n                                overflow[alignmentSides[0]],\n                                overflow[alignmentSides[1]]\n                            ];\n                            allOverflows = _to_consumable_array(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []).concat([\n                                {\n                                    placement: currentPlacement,\n                                    overflows: currentOverflows\n                                }\n                            ]);\n                            nextPlacement = placements$1[currentIndex + 1];\n                            // There are more placements to check.\n                            if (nextPlacement) {\n                                return [\n                                    2,\n                                    {\n                                        data: {\n                                            index: currentIndex + 1,\n                                            overflows: allOverflows\n                                        },\n                                        reset: {\n                                            placement: nextPlacement\n                                        }\n                                    }\n                                ];\n                            }\n                            placementsSortedByMostSpace = allOverflows.map(function(d) {\n                                var alignment = getAlignment(d.placement);\n                                return [\n                                    d.placement,\n                                    alignment && crossAxis ? // Check along the mainAxis and main crossAxis side.\n                                    d.overflows.slice(0, 2).reduce(function(acc, v) {\n                                        return acc + v;\n                                    }, 0) : // Check only the mainAxis.\n                                    d.overflows[0],\n                                    d.overflows\n                                ];\n                            }).sort(function(a, b) {\n                                return a[1] - b[1];\n                            });\n                            placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(function(d) {\n                                return d[2].slice(0, // Aligned placements should not check their opposite crossAxis\n                                // side.\n                                getAlignment(d[0]) ? 2 : 3).every(function(v) {\n                                    return v <= 0;\n                                });\n                            });\n                            resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n                            if (resetPlacement !== placement) {\n                                return [\n                                    2,\n                                    {\n                                        data: {\n                                            index: currentIndex + 1,\n                                            overflows: allOverflows\n                                        },\n                                        reset: {\n                                            placement: resetPlacement\n                                        }\n                                    }\n                                ];\n                            }\n                            return [\n                                2,\n                                {}\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */ var flip = function flip(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"flip\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var _middlewareData$arrow, _middlewareData$flip, placement, middlewareData, rects, initialPlacement, platform, elements, _evaluate, tmp, checkMainAxis, tmp1, checkCrossAxis, specifiedFallbackPlacements, _evaluate_fallbackStrategy, fallbackStrategy, _evaluate_fallbackAxisSideDirection, fallbackAxisSideDirection, _evaluate_flipAlignment, flipAlignment, detectOverflowOptions, side, isBasePlacement, rtl, fallbackPlacements, _fallbackPlacements, placements, overflow, overflows, overflowsData, sides, _middlewareData$flip2, _overflowsData$filter, nextIndex, nextPlacement, resetPlacement, _overflowsData$map$so, placement1;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            placement = state.placement, middlewareData = state.middlewareData, rects = state.rects, initialPlacement = state.initialPlacement, platform = state.platform, elements = state.elements;\n                            _evaluate = evaluate(options, state), tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? true : tmp1, specifiedFallbackPlacements = _evaluate.fallbackPlacements, _evaluate_fallbackStrategy = _evaluate.fallbackStrategy, fallbackStrategy = _evaluate_fallbackStrategy === void 0 ? \"bestFit\" : _evaluate_fallbackStrategy, _evaluate_fallbackAxisSideDirection = _evaluate.fallbackAxisSideDirection, fallbackAxisSideDirection = _evaluate_fallbackAxisSideDirection === void 0 ? \"none\" : _evaluate_fallbackAxisSideDirection, _evaluate_flipAlignment = _evaluate.flipAlignment, flipAlignment = _evaluate_flipAlignment === void 0 ? true : _evaluate_flipAlignment, detectOverflowOptions = _object_without_properties(_evaluate, [\n                                \"mainAxis\",\n                                \"crossAxis\",\n                                \"fallbackPlacements\",\n                                \"fallbackStrategy\",\n                                \"fallbackAxisSideDirection\",\n                                \"flipAlignment\"\n                            ]);\n                            // If a reset by the arrow was caused due to an alignment offset being\n                            // added, we should skip any logic now since `flip()` has already done its\n                            // work.\n                            // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n                            if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n                                return [\n                                    2,\n                                    {}\n                                ];\n                            }\n                            side = getSide(placement);\n                            isBasePlacement = getSide(initialPlacement) === initialPlacement;\n                            return [\n                                4,\n                                platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)\n                            ];\n                        case 1:\n                            rtl = _state.sent();\n                            fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [\n                                getOppositePlacement(initialPlacement)\n                            ] : getExpandedPlacements(initialPlacement));\n                            if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== \"none\") {\n                                ;\n                                (_fallbackPlacements = fallbackPlacements).push.apply(_fallbackPlacements, _to_consumable_array(getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl)));\n                            }\n                            placements = [\n                                initialPlacement\n                            ].concat(_to_consumable_array(fallbackPlacements));\n                            return [\n                                4,\n                                detectOverflow(state, detectOverflowOptions)\n                            ];\n                        case 2:\n                            overflow = _state.sent();\n                            overflows = [];\n                            overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n                            if (checkMainAxis) {\n                                overflows.push(overflow[side]);\n                            }\n                            if (checkCrossAxis) {\n                                sides = getAlignmentSides(placement, rects, rtl);\n                                overflows.push(overflow[sides[0]], overflow[sides[1]]);\n                            }\n                            overflowsData = _to_consumable_array(overflowsData).concat([\n                                {\n                                    placement: placement,\n                                    overflows: overflows\n                                }\n                            ]);\n                            // One or more sides is overflowing.\n                            if (!overflows.every(function(side) {\n                                return side <= 0;\n                            })) {\n                                ;\n                                nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n                                nextPlacement = placements[nextIndex];\n                                if (nextPlacement) {\n                                    // Try next placement and re-run the lifecycle.\n                                    return [\n                                        2,\n                                        {\n                                            data: {\n                                                index: nextIndex,\n                                                overflows: overflowsData\n                                            },\n                                            reset: {\n                                                placement: nextPlacement\n                                            }\n                                        }\n                                    ];\n                                }\n                                // First, find the candidates that fit on the mainAxis side of overflow,\n                                // then find the placement that fits the best on the main crossAxis side.\n                                resetPlacement = (_overflowsData$filter = overflowsData.filter(function(d) {\n                                    return d.overflows[0] <= 0;\n                                }).sort(function(a, b) {\n                                    return a.overflows[1] - b.overflows[1];\n                                })[0]) == null ? void 0 : _overflowsData$filter.placement;\n                                // Otherwise fallback.\n                                if (!resetPlacement) {\n                                    switch(fallbackStrategy){\n                                        case \"bestFit\":\n                                            {\n                                                ;\n                                                placement1 = (_overflowsData$map$so = overflowsData.map(function(d) {\n                                                    return [\n                                                        d.placement,\n                                                        d.overflows.filter(function(overflow) {\n                                                            return overflow > 0;\n                                                        }).reduce(function(acc, overflow) {\n                                                            return acc + overflow;\n                                                        }, 0)\n                                                    ];\n                                                }).sort(function(a, b) {\n                                                    return a[1] - b[1];\n                                                })[0]) == null ? void 0 : _overflowsData$map$so[0];\n                                                if (placement1) {\n                                                    resetPlacement = placement1;\n                                                }\n                                                break;\n                                            }\n                                        case \"initialPlacement\":\n                                            resetPlacement = initialPlacement;\n                                            break;\n                                    }\n                                }\n                                if (placement !== resetPlacement) {\n                                    return [\n                                        2,\n                                        {\n                                            reset: {\n                                                placement: resetPlacement\n                                            }\n                                        }\n                                    ];\n                                }\n                            }\n                            return [\n                                2,\n                                {}\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\nfunction getSideOffsets(overflow, rect) {\n    return {\n        top: overflow.top - rect.height,\n        right: overflow.right - rect.width,\n        bottom: overflow.bottom - rect.height,\n        left: overflow.left - rect.width\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return sides.some(function(side) {\n        return overflow[side] >= 0;\n    });\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */ var hide = function hide(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"hide\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var rects, _evaluate, _evaluate_strategy, strategy, detectOverflowOptions, overflow, offsets, overflow1, offsets1;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            rects = state.rects;\n                            _evaluate = evaluate(options, state), _evaluate_strategy = _evaluate.strategy, strategy = _evaluate_strategy === void 0 ? \"referenceHidden\" : _evaluate_strategy, detectOverflowOptions = _object_without_properties(_evaluate, [\n                                \"strategy\"\n                            ]);\n                            switch(strategy){\n                                case \"referenceHidden\":\n                                    return [\n                                        3,\n                                        1\n                                    ];\n                                case \"escaped\":\n                                    return [\n                                        3,\n                                        3\n                                    ];\n                            }\n                            return [\n                                3,\n                                5\n                            ];\n                        case 1:\n                            return [\n                                4,\n                                detectOverflow(state, _object_spread_props(_object_spread({}, detectOverflowOptions), {\n                                    elementContext: \"reference\"\n                                }))\n                            ];\n                        case 2:\n                            overflow = _state.sent();\n                            offsets = getSideOffsets(overflow, rects.reference);\n                            return [\n                                2,\n                                {\n                                    data: {\n                                        referenceHiddenOffsets: offsets,\n                                        referenceHidden: isAnySideFullyClipped(offsets)\n                                    }\n                                }\n                            ];\n                        case 3:\n                            return [\n                                4,\n                                detectOverflow(state, _object_spread_props(_object_spread({}, detectOverflowOptions), {\n                                    altBoundary: true\n                                }))\n                            ];\n                        case 4:\n                            overflow1 = _state.sent();\n                            offsets1 = getSideOffsets(overflow1, rects.floating);\n                            return [\n                                2,\n                                {\n                                    data: {\n                                        escapedOffsets: offsets1,\n                                        escaped: isAnySideFullyClipped(offsets1)\n                                    }\n                                }\n                            ];\n                        case 5:\n                            {\n                                return [\n                                    2,\n                                    {}\n                                ];\n                            }\n                            _state.label = 6;\n                        case 6:\n                            return [\n                                2\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\nfunction getBoundingRect(rects) {\n    var minX = min.apply(void 0, _to_consumable_array(rects.map(function(rect) {\n        return rect.left;\n    })));\n    var minY = min.apply(void 0, _to_consumable_array(rects.map(function(rect) {\n        return rect.top;\n    })));\n    var maxX = max.apply(void 0, _to_consumable_array(rects.map(function(rect) {\n        return rect.right;\n    })));\n    var maxY = max.apply(void 0, _to_consumable_array(rects.map(function(rect) {\n        return rect.bottom;\n    })));\n    return {\n        x: minX,\n        y: minY,\n        width: maxX - minX,\n        height: maxY - minY\n    };\n}\nfunction getRectsByLine(rects) {\n    var sortedRects = rects.slice().sort(function(a, b) {\n        return a.y - b.y;\n    });\n    var groups = [];\n    var prevRect = null;\n    for(var i = 0; i < sortedRects.length; i++){\n        var rect = sortedRects[i];\n        if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n            groups.push([\n                rect\n            ]);\n        } else {\n            groups[groups.length - 1].push(rect);\n        }\n        prevRect = rect;\n    }\n    return groups.map(function(rect) {\n        return rectToClientRect(getBoundingRect(rect));\n    });\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */ var inline = function inline(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"inline\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var placement, elements, rects, platform, strategy, _evaluate, _evaluate_padding, padding, x, y, nativeClientRects, _, clientRects, fallback, paddingObject, resetRects;\n                function getBoundingClientRect() {\n                    // There are two rects and they are disjoined.\n                    if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n                        // Find the first rect in which the point is fully inside.\n                        return clientRects.find(function(rect) {\n                            return x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom;\n                        }) || fallback;\n                    }\n                    // There are 2 or more connected rects.\n                    if (clientRects.length >= 2) {\n                        if (getSideAxis(placement) === \"y\") {\n                            var firstRect = clientRects[0];\n                            var lastRect = clientRects[clientRects.length - 1];\n                            var isTop = getSide(placement) === \"top\";\n                            var top = firstRect.top;\n                            var bottom = lastRect.bottom;\n                            var left = isTop ? firstRect.left : lastRect.left;\n                            var right = isTop ? firstRect.right : lastRect.right;\n                            var width = right - left;\n                            var height = bottom - top;\n                            return {\n                                top: top,\n                                bottom: bottom,\n                                left: left,\n                                right: right,\n                                width: width,\n                                height: height,\n                                x: left,\n                                y: top\n                            };\n                        }\n                        var isLeftSide = getSide(placement) === \"left\";\n                        var maxRight = max.apply(void 0, _to_consumable_array(clientRects.map(function(rect) {\n                            return rect.right;\n                        })));\n                        var minLeft = min.apply(void 0, _to_consumable_array(clientRects.map(function(rect) {\n                            return rect.left;\n                        })));\n                        var measureRects = clientRects.filter(function(rect) {\n                            return isLeftSide ? rect.left === minLeft : rect.right === maxRight;\n                        });\n                        var top1 = measureRects[0].top;\n                        var bottom1 = measureRects[measureRects.length - 1].bottom;\n                        var left1 = minLeft;\n                        var right1 = maxRight;\n                        var width1 = right1 - left1;\n                        var height1 = bottom1 - top1;\n                        return {\n                            top: top1,\n                            bottom: bottom1,\n                            left: left1,\n                            right: right1,\n                            width: width1,\n                            height: height1,\n                            x: left1,\n                            y: top1\n                        };\n                    }\n                    return fallback;\n                }\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            placement = state.placement, elements = state.elements, rects = state.rects, platform = state.platform, strategy = state.strategy;\n                            // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n                            // ClientRect's bounds, despite the event listener being triggered. A\n                            // padding of 2 seems to handle this issue.\n                            _evaluate = evaluate(options, state), _evaluate_padding = _evaluate.padding, padding = _evaluate_padding === void 0 ? 2 : _evaluate_padding, x = _evaluate.x, y = _evaluate.y;\n                            _ = Array.from;\n                            return [\n                                4,\n                                platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference)\n                            ];\n                        case 1:\n                            nativeClientRects = _.apply(Array, [\n                                _state.sent() || []\n                            ]);\n                            clientRects = getRectsByLine(nativeClientRects);\n                            fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n                            paddingObject = getPaddingObject(padding);\n                            return [\n                                4,\n                                platform.getElementRects({\n                                    reference: {\n                                        getBoundingClientRect: getBoundingClientRect\n                                    },\n                                    floating: elements.floating,\n                                    strategy: strategy\n                                })\n                            ];\n                        case 2:\n                            resetRects = _state.sent();\n                            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n                                return [\n                                    2,\n                                    {\n                                        reset: {\n                                            rects: resetRects\n                                        }\n                                    }\n                                ];\n                            }\n                            return [\n                                2,\n                                {}\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\nfunction convertValueToCoords(state, options) {\n    return _convertValueToCoords.apply(this, arguments);\n}\nfunction _convertValueToCoords() {\n    _convertValueToCoords = // For type backwards-compatibility, the `OffsetOptions` type was also\n    // Derivable.\n    _async_to_generator(function(state, options) {\n        var placement, platform, elements, rtl, side, alignment, isVertical, mainAxisMulti, crossAxisMulti, rawValue, _ref, mainAxis, crossAxis, alignmentAxis;\n        return _ts_generator(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    placement = state.placement, platform = state.platform, elements = state.elements;\n                    return [\n                        4,\n                        platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)\n                    ];\n                case 1:\n                    rtl = _state.sent();\n                    side = getSide(placement);\n                    alignment = getAlignment(placement);\n                    isVertical = getSideAxis(placement) === \"y\";\n                    mainAxisMulti = [\n                        \"left\",\n                        \"top\"\n                    ].includes(side) ? -1 : 1;\n                    crossAxisMulti = rtl && isVertical ? -1 : 1;\n                    rawValue = evaluate(options, state);\n                    // eslint-disable-next-line prefer-const\n                    _ref = typeof rawValue === \"number\" ? {\n                        mainAxis: rawValue,\n                        crossAxis: 0,\n                        alignmentAxis: null\n                    } : _object_spread({\n                        mainAxis: 0,\n                        crossAxis: 0,\n                        alignmentAxis: null\n                    }, rawValue), mainAxis = _ref.mainAxis, crossAxis = _ref.crossAxis, alignmentAxis = _ref.alignmentAxis;\n                    if (alignment && typeof alignmentAxis === \"number\") {\n                        crossAxis = alignment === \"end\" ? alignmentAxis * -1 : alignmentAxis;\n                    }\n                    return [\n                        2,\n                        isVertical ? {\n                            x: crossAxis * crossAxisMulti,\n                            y: mainAxis * mainAxisMulti\n                        } : {\n                            x: mainAxis * mainAxisMulti,\n                            y: crossAxis * crossAxisMulti\n                        }\n                    ];\n            }\n        });\n    });\n    return _convertValueToCoords.apply(this, arguments);\n}\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */ var offset = function offset(options) {\n    if (options === void 0) {\n        options = 0;\n    }\n    return {\n        name: \"offset\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var x, y, diffCoords;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            x = state.x, y = state.y;\n                            return [\n                                4,\n                                convertValueToCoords(state, options)\n                            ];\n                        case 1:\n                            diffCoords = _state.sent();\n                            return [\n                                2,\n                                {\n                                    x: x + diffCoords.x,\n                                    y: y + diffCoords.y,\n                                    data: diffCoords\n                                }\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */ var shift = function shift(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"shift\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var x, y, placement, _evaluate, tmp, checkMainAxis, tmp1, checkCrossAxis, _evaluate_limiter, limiter, detectOverflowOptions, coords, overflow, crossAxis, mainAxis, mainAxisCoord, crossAxisCoord, minSide, maxSide, min, max, minSide1, maxSide1, min1, max1, _obj, limitedCoords;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            x = state.x, y = state.y, placement = state.placement;\n                            _evaluate = evaluate(options, state), tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? false : tmp1, _evaluate_limiter = _evaluate.limiter, limiter = _evaluate_limiter === void 0 ? {\n                                fn: function(_ref) {\n                                    var x = _ref.x, y = _ref.y;\n                                    return {\n                                        x: x,\n                                        y: y\n                                    };\n                                }\n                            } : _evaluate_limiter, detectOverflowOptions = _object_without_properties(_evaluate, [\n                                \"mainAxis\",\n                                \"crossAxis\",\n                                \"limiter\"\n                            ]);\n                            coords = {\n                                x: x,\n                                y: y\n                            };\n                            return [\n                                4,\n                                detectOverflow(state, detectOverflowOptions)\n                            ];\n                        case 1:\n                            overflow = _state.sent();\n                            crossAxis = getSideAxis(getSide(placement));\n                            mainAxis = getOppositeAxis(crossAxis);\n                            mainAxisCoord = coords[mainAxis];\n                            crossAxisCoord = coords[crossAxis];\n                            if (checkMainAxis) {\n                                minSide = mainAxis === \"y\" ? \"top\" : \"left\";\n                                maxSide = mainAxis === \"y\" ? \"bottom\" : \"right\";\n                                min = mainAxisCoord + overflow[minSide];\n                                max = mainAxisCoord - overflow[maxSide];\n                                mainAxisCoord = clamp(min, mainAxisCoord, max);\n                            }\n                            if (checkCrossAxis) {\n                                minSide1 = crossAxis === \"y\" ? \"top\" : \"left\";\n                                maxSide1 = crossAxis === \"y\" ? \"bottom\" : \"right\";\n                                min1 = crossAxisCoord + overflow[minSide1];\n                                max1 = crossAxisCoord - overflow[maxSide1];\n                                crossAxisCoord = clamp(min1, crossAxisCoord, max1);\n                            }\n                            limitedCoords = limiter.fn(_object_spread_props(_object_spread({}, state), (_obj = {}, _define_property(_obj, mainAxis, mainAxisCoord), _define_property(_obj, crossAxis, crossAxisCoord), _obj)));\n                            return [\n                                2,\n                                _object_spread_props(_object_spread({}, limitedCoords), {\n                                    data: {\n                                        x: limitedCoords.x - x,\n                                        y: limitedCoords.y - y\n                                    }\n                                })\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */ var limitShift = function limitShift(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        options: options,\n        fn: function fn(state) {\n            var x = state.x, y = state.y, placement = state.placement, rects = state.rects, middlewareData = state.middlewareData;\n            var _evaluate = evaluate(options, state), _evaluate_offset = _evaluate.offset, offset = _evaluate_offset === void 0 ? 0 : _evaluate_offset, tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? true : tmp1;\n            var coords = {\n                x: x,\n                y: y\n            };\n            var crossAxis = getSideAxis(placement);\n            var mainAxis = getOppositeAxis(crossAxis);\n            var mainAxisCoord = coords[mainAxis];\n            var crossAxisCoord = coords[crossAxis];\n            var rawOffset = evaluate(offset, state);\n            var computedOffset = typeof rawOffset === \"number\" ? {\n                mainAxis: rawOffset,\n                crossAxis: 0\n            } : _object_spread({\n                mainAxis: 0,\n                crossAxis: 0\n            }, rawOffset);\n            if (checkMainAxis) {\n                var len = mainAxis === \"y\" ? \"height\" : \"width\";\n                var limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n                var limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n                if (mainAxisCoord < limitMin) {\n                    mainAxisCoord = limitMin;\n                } else if (mainAxisCoord > limitMax) {\n                    mainAxisCoord = limitMax;\n                }\n            }\n            if (checkCrossAxis) {\n                var _middlewareData$offse, _middlewareData$offse2;\n                var len1 = mainAxis === \"y\" ? \"width\" : \"height\";\n                var isOriginSide = [\n                    \"top\",\n                    \"left\"\n                ].includes(getSide(placement));\n                var limitMin1 = rects.reference[crossAxis] - rects.floating[len1] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n                var limitMax1 = rects.reference[crossAxis] + rects.reference[len1] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n                if (crossAxisCoord < limitMin1) {\n                    crossAxisCoord = limitMin1;\n                } else if (crossAxisCoord > limitMax1) {\n                    crossAxisCoord = limitMax1;\n                }\n            }\n            var _obj;\n            return _obj = {}, _define_property(_obj, mainAxis, mainAxisCoord), _define_property(_obj, crossAxis, crossAxisCoord), _obj;\n        }\n    };\n};\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */ var size = function size(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return {\n        name: \"size\",\n        options: options,\n        fn: function fn(state) {\n            return _async_to_generator(function() {\n                var placement, rects, platform, elements, _evaluate, _evaluate_apply, apply, detectOverflowOptions, overflow, side, alignment, isYAxis, _rects_floating, width, height, heightSide, widthSide, overflowAvailableHeight, overflowAvailableWidth, noShift, availableHeight, availableWidth, maximumClippingWidth, maximumClippingHeight, xMin, xMax, yMin, yMax, nextDimensions;\n                return _ts_generator(this, function(_state) {\n                    switch(_state.label){\n                        case 0:\n                            placement = state.placement, rects = state.rects, platform = state.platform, elements = state.elements;\n                            _evaluate = evaluate(options, state), _evaluate_apply = _evaluate.apply, apply = _evaluate_apply === void 0 ? function() {} : _evaluate_apply, detectOverflowOptions = _object_without_properties(_evaluate, [\n                                \"apply\"\n                            ]);\n                            return [\n                                4,\n                                detectOverflow(state, detectOverflowOptions)\n                            ];\n                        case 1:\n                            overflow = _state.sent();\n                            side = getSide(placement);\n                            alignment = getAlignment(placement);\n                            isYAxis = getSideAxis(placement) === \"y\";\n                            _rects_floating = rects.floating, width = _rects_floating.width, height = _rects_floating.height;\n                            if (!(side === \"top\" || side === \"bottom\")) return [\n                                3,\n                                3\n                            ];\n                            heightSide = side;\n                            return [\n                                4,\n                                platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)\n                            ];\n                        case 2:\n                            widthSide = alignment === (_state.sent() ? \"start\" : \"end\") ? \"left\" : \"right\";\n                            return [\n                                3,\n                                4\n                            ];\n                        case 3:\n                            widthSide = side;\n                            heightSide = alignment === \"end\" ? \"top\" : \"bottom\";\n                            _state.label = 4;\n                        case 4:\n                            overflowAvailableHeight = height - overflow[heightSide];\n                            overflowAvailableWidth = width - overflow[widthSide];\n                            noShift = !state.middlewareData.shift;\n                            availableHeight = overflowAvailableHeight;\n                            availableWidth = overflowAvailableWidth;\n                            if (isYAxis) {\n                                maximumClippingWidth = width - overflow.left - overflow.right;\n                                availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n                            } else {\n                                maximumClippingHeight = height - overflow.top - overflow.bottom;\n                                availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n                            }\n                            if (noShift && !alignment) {\n                                xMin = max(overflow.left, 0);\n                                xMax = max(overflow.right, 0);\n                                yMin = max(overflow.top, 0);\n                                yMax = max(overflow.bottom, 0);\n                                if (isYAxis) {\n                                    availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n                                } else {\n                                    availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n                                }\n                            }\n                            return [\n                                4,\n                                apply(_object_spread_props(_object_spread({}, state), {\n                                    availableWidth: availableWidth,\n                                    availableHeight: availableHeight\n                                }))\n                            ];\n                        case 5:\n                            _state.sent();\n                            return [\n                                4,\n                                platform.getDimensions(elements.floating)\n                            ];\n                        case 6:\n                            nextDimensions = _state.sent();\n                            if (width !== nextDimensions.width || height !== nextDimensions.height) {\n                                return [\n                                    2,\n                                    {\n                                        reset: {\n                                            rects: true\n                                        }\n                                    }\n                                ];\n                            }\n                            return [\n                                2,\n                                {}\n                            ];\n                    }\n                });\n            })();\n        }\n    };\n};\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}