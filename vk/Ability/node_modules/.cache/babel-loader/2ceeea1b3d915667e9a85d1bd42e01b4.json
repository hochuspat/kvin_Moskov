{"ast":null,"code":"import { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\n\nfunction prepareSize(size) {\n  return {\n    url: size.url || size.src || \"\",\n    width: size.width,\n    height: size.height\n  };\n}\n\nfunction computeSize(sizes, minWidth) {\n  var minHeight = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null; // Do nothing if sizes contains only 1 item\n\n  if (sizes.length === 1) {\n    return sizes[0];\n  } // Sorting in ascending order\n\n\n  var sorted = _to_consumable_array(sizes).sort(function (a, b) {\n    if (a.width < b.width) {\n      return -1;\n    }\n\n    if (a.width === b.width) {\n      return a.height > b.height ? 1 : -1;\n    }\n\n    return 1;\n  });\n\n  var matchesByWidth = sorted.filter(function (size) {\n    return size.width >= minWidth;\n  });\n\n  if (!matchesByWidth.length) {\n    // Biggest size\n    return sorted[sorted.length - 1];\n  }\n\n  if (!minHeight) {\n    return matchesByWidth[0];\n  } // Searching by height\n\n\n  for (var i = 0; i < matchesByWidth.length; i++) {\n    var size = matchesByWidth[i];\n\n    if (size.height >= minHeight) {\n      return size;\n    }\n  } // Sorting by height in ascending order\n\n\n  var sortedByHeight = matchesByWidth.sort(function (a, b) {\n    return a.height > b.height ? 1 : -1;\n  });\n  return sortedByHeight[sortedByHeight.length - 1];\n}\n/**\n * Searches for the smallest (?) suitable image from the sizes array.\n *\n * Or more precise, it returns:\n *   – if no suitable sizes (>= minWidth И >= minHeight): the biggest from all sizes;\n *   – there are any suitable (>= minWidth И >= minHeight): the smallest of the matching sizes;\n *\n * Returns null only in case of an empty/invalid array. The returned size can be smaller than minWidth or minHeight.\n *\n * The function doesn't take into about the retina screen (window.devicePixelRatio), so you have to calculate the right width/height from the outside to support it.\n *\n * WARN:\n * - does not reckon for letter-sizes (PhotosPhotoSizesType).\n * - does not know how to search for the \"nearest\" size, or the maximum image (there is a hack with the `Infinity` pass).\n *\n * @example\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 1) // => 1,1\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 2) // => 3,3\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 4) // => 3,3\n *\n * See more examples in tests\n */\n\n\nexport function getPhotoSize(sizes, minWidth) {\n  var minHeight = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;\n\n  if (!Array.isArray(sizes) || !sizes.length) {\n    return null;\n  }\n\n  var size = computeSize(sizes, minWidth, minHeight);\n  return prepareSize(size);\n}","map":{"version":3,"mappings":";;AAaA,SAASA,WAAT,CAAqBC,IAArB,EAAwC;EACtC,OAAO;IACLC,KAAKD,KAAKC,GAALD,IAAYA,KAAKE,GAAjBF,IAAwB,EADxB;IAELG,OAAOH,KAAKG,KAFP;IAGLC,QAAQJ,KAAKI;EAHR,CAAP;AAKF;;AAEA,SAASC,WAAT,CACEC,KADF,EAEEC,QAFF,EAEkB;MAChBC,6EAA2B,KADX,CAGhB;;EACA,IAAIF,MAAMG,MAANH,KAAiB,CAArB,EAAwB;IACtB,OAAOA,KAAK,CAAC,CAAD,CAAZ;EACF,CANgB,CAQhB;;;EACA,IAAMI,SAASC,oBAAC,CAAGL,KAAH,CAAD,CAAWM,IAAX,CAAgB,UAACC,CAAD,EAAIC,CAAJ,EAAIA;IACjC,IAAID,EAAEV,KAAFU,GAAUC,EAAEX,KAAhB,EAAuB;MACrB,OAAO,CAAC,CAAR;IACF;;IAEA,IAAIU,EAAEV,KAAFU,KAAYC,EAAEX,KAAlB,EAAyB;MACvB,OAAOU,EAAET,MAAFS,GAAWC,EAAEV,MAAbS,GAAsB,CAAtBA,GAA0B,CAAC,CAAlC;IACF;;IAEA,OAAO,CAAP;EACF,CAVe,CAAf;;EAYA,IAAME,iBAAiBL,OAAOM,MAAPN,CAAc,UAACV,IAAD,EAACA;WAASA,KAAKG,KAALH,IAAcO;GAAtCG,CAAvB;;EACA,IAAI,CAACK,eAAeN,MAApB,EAA4B;IAC1B;IACA,OAAOC,MAAM,CAACA,OAAOD,MAAPC,GAAgB,CAAjB,CAAb;EACF;;EAEA,IAAI,CAACF,SAAL,EAAgB;IACd,OAAOO,cAAc,CAAC,CAAD,CAArB;EACF,CA7BgB,CA+BhB;;;EACA,KAAK,IAAIE,IAAI,CAAb,EAAgBA,IAAIF,eAAeN,MAAnC,EAA2CQ,GAA3C,EAAgD;IAC9C,IAAMjB,OAAOe,cAAc,CAACE,CAAD,CAA3B;;IACA,IAAIjB,KAAKI,MAALJ,IAAeQ,SAAnB,EAA8B;MAC5B,OAAOR,IAAP;IACF;EACF,CArCgB,CAuChB;;;EACA,IAAMkB,iBAAiBH,eAAeH,IAAfG,CAAoB,UAACF,CAAD,EAAIC,CAAJ,EAAIA;WAAOD,EAAET,MAAFS,GAAWC,EAAEV,MAAbS,GAAsB,CAAtBA,GAA0B,CAAC;GAA1DE,CAAvB;EAEA,OAAOG,cAAc,CAACA,eAAeT,MAAfS,GAAwB,CAAzB,CAArB;AACF;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAO,SAASC,YAAT,CACLb,KADK,EAELC,QAFK,EAEW;MAChBC,6EAA2B;;EAE3B,IAAI,CAACY,MAAMC,OAAND,CAAcd,KAAdc,CAAD,IAAyB,CAACd,MAAMG,MAApC,EAA4C;IAC1C,OAAO,IAAP;EACF;;EAEA,IAAMT,OAAOK,YAAYC,KAAZD,EAAmBE,QAAnBF,EAA6BG,SAA7BH,CAAb;EAEA,OAAON,YAAYC,IAAZD,CAAP;AACF","names":["prepareSize","size","url","src","width","height","computeSize","sizes","minWidth","minHeight","length","sorted","_to_consumable_array","sort","a","b","matchesByWidth","filter","i","sortedByHeight","getPhotoSize","Array","isArray"],"sources":["C:\\Users\\kulag\\vk\\Ability\\node_modules\\@vkontakte\\vkjs\\src\\getPhotoSize.ts"],"sourcesContent":["export interface PhotoSizeLike {\n  width: number;\n  height: number;\n  url?: string;\n  src?: string;\n}\n\nexport interface PhotoSize {\n  url: string;\n  width: number;\n  height: number;\n}\n\nfunction prepareSize(size: PhotoSizeLike): PhotoSize {\n  return {\n    url: size.url || size.src || '',\n    width: size.width,\n    height: size.height,\n  };\n}\n\nfunction computeSize(\n  sizes: PhotoSizeLike[],\n  minWidth: number,\n  minHeight: number | null = null,\n): PhotoSizeLike {\n  // Do nothing if sizes contains only 1 item\n  if (sizes.length === 1) {\n    return sizes[0];\n  }\n\n  // Sorting in ascending order\n  const sorted = [...sizes].sort((a, b) => {\n    if (a.width < b.width) {\n      return -1;\n    }\n\n    if (a.width === b.width) {\n      return a.height > b.height ? 1 : -1;\n    }\n\n    return 1;\n  });\n\n  const matchesByWidth = sorted.filter((size) => size.width >= minWidth);\n  if (!matchesByWidth.length) {\n    // Biggest size\n    return sorted[sorted.length - 1];\n  }\n\n  if (!minHeight) {\n    return matchesByWidth[0];\n  }\n\n  // Searching by height\n  for (let i = 0; i < matchesByWidth.length; i++) {\n    const size = matchesByWidth[i];\n    if (size.height >= minHeight) {\n      return size;\n    }\n  }\n\n  // Sorting by height in ascending order\n  const sortedByHeight = matchesByWidth.sort((a, b) => (a.height > b.height ? 1 : -1));\n\n  return sortedByHeight[sortedByHeight.length - 1];\n}\n\n/**\n * Searches for the smallest (?) suitable image from the sizes array.\n *\n * Or more precise, it returns:\n *   – if no suitable sizes (>= minWidth И >= minHeight): the biggest from all sizes;\n *   – there are any suitable (>= minWidth И >= minHeight): the smallest of the matching sizes;\n *\n * Returns null only in case of an empty/invalid array. The returned size can be smaller than minWidth or minHeight.\n *\n * The function doesn't take into about the retina screen (window.devicePixelRatio), so you have to calculate the right width/height from the outside to support it.\n *\n * WARN:\n * - does not reckon for letter-sizes (PhotosPhotoSizesType).\n * - does not know how to search for the \"nearest\" size, or the maximum image (there is a hack with the `Infinity` pass).\n *\n * @example\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 1) // => 1,1\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 2) // => 3,3\n *   getPhotoSize([{ width: 1, height: 1 }, { width: 3, height: 3 }], 4) // => 3,3\n *\n * See more examples in tests\n */\nexport function getPhotoSize(\n  sizes: PhotoSizeLike[],\n  minWidth: number,\n  minHeight: number | null = null,\n): PhotoSize | null {\n  if (!Array.isArray(sizes) || !sizes.length) {\n    return null;\n  }\n\n  const size = computeSize(sizes, minWidth, minHeight);\n\n  return prepareSize(size);\n}\n"]},"metadata":{},"sourceType":"module"}