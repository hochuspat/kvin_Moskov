{"ast":null,"code":"import { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _sliced_to_array } from \"@swc/helpers/_/_sliced_to_array\";\nimport * as React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { hasReactNode } from \"@vkontakte/vkjs\";\nimport { useExternRef } from \"../../hooks/useExternRef\";\nimport { arrowMiddleware, autoPlacementMiddleware, autoUpdateFloatingElement, checkIsNotAutoPlacement, convertFloatingDataToReactCSSProperties, flipMiddleware, getAutoPlacementAlign, offsetMiddleware, shiftMiddleware, useFloating } from \"../../lib/floating\";\nimport { warnOnce } from \"../../lib/warnOnce\";\nimport { useNavTransition } from \"../NavTransitionContext/NavTransitionContext\";\nimport { TOOLTIP_MAX_WIDTH, TooltipBase } from \"../TooltipBase/TooltipBase\";\nimport { tooltipContainerAttr } from \"./TooltipContainer\";\n\nvar isDOMTypeElement = function (element) {\n  return /*#__PURE__*/React.isValidElement(element) && typeof element.type === \"string\";\n};\n\nvar warn = warnOnce(\"Tooltip\");\n\nfunction mapAlignX(x) {\n  switch (x) {\n    case \"left\":\n      return \"start\";\n\n    case \"right\":\n      return \"end\";\n\n    default:\n      return \"\";\n  }\n}\n\nfunction getDefaultPlacement(alignX, alignY) {\n  return [alignY || \"bottom\", mapAlignX(alignX || \"left\")].filter(function (p) {\n    return !!p;\n  }).join(\"-\");\n}\n\nfunction isVerticalPlacement(placement) {\n  return placement.startsWith(\"top\") || placement.startsWith(\"bottom\");\n}\n/**\n * @see https://vkcom.github.io/VKUI/#/Tooltip\n */\n\n\nexport var Tooltip = function (_param) {\n  var children = _param.children,\n      tmp = _param.isShown,\n      isShownProp = tmp === void 0 ? true : tmp,\n      _param_offsetX = _param.offsetX,\n      offsetX = _param_offsetX === void 0 ? 0 : _param_offsetX,\n      _param_offsetY = _param.offsetY,\n      offsetY = _param_offsetY === void 0 ? 15 : _param_offsetY,\n      alignX = _param.alignX,\n      alignY = _param.alignY,\n      onClose = _param.onClose,\n      _param_cornerOffset = _param.cornerOffset,\n      cornerOffset = _param_cornerOffset === void 0 ? 0 : _param_cornerOffset,\n      cornerAbsoluteOffset = _param.cornerAbsoluteOffset,\n      _param_arrow = _param.arrow,\n      arrow = _param_arrow === void 0 ? true : _param_arrow,\n      _param_arrowPadding = _param.arrowPadding,\n      arrowPadding = _param_arrowPadding === void 0 ? 14 : _param_arrowPadding,\n      placementProp = _param.placement,\n      _param_maxWidth = _param.maxWidth,\n      maxWidth = _param_maxWidth === void 0 ? TOOLTIP_MAX_WIDTH : _param_maxWidth,\n      restProps = _object_without_properties(_param, [\"children\", \"isShown\", \"offsetX\", \"offsetY\", \"alignX\", \"alignY\", \"onClose\", \"cornerOffset\", \"cornerAbsoluteOffset\", \"arrow\", \"arrowPadding\", \"placement\", \"maxWidth\"]);\n\n  var _React_useState = _sliced_to_array(React.useState(null), 2),\n      arrowRef = _React_useState[0],\n      setArrowRef = _React_useState[1];\n\n  var _React_useState1 = _sliced_to_array(React.useState(null), 2),\n      target = _React_useState1[0],\n      setTarget = _React_useState1[1];\n  /* eslint-disable no-restricted-properties */\n\n\n  var tooltipContainer = React.useMemo(function () {\n    return target === null || target === void 0 ? void 0 : target.closest(\"[\".concat(tooltipContainerAttr, \"]\"));\n  }, [target]);\n  var entering = useNavTransition().entering;\n  var isShown = isShownProp && tooltipContainer && !entering;\n  var placement = placementProp || getDefaultPlacement(alignX, alignY);\n  var isNotAutoPlacement = checkIsNotAutoPlacement(placement);\n\n  if (process.env.NODE_ENV === \"development\") {\n    var multiChildren = React.Children.count(children) > 1; // Empty children is a noop\n\n    var primitiveChild = hasReactNode(children) && typeof children !== \"object\";\n    (multiChildren || primitiveChild) && warn([\"children должен быть одним React элементом, получено\", multiChildren && \"несколько\", primitiveChild && JSON.stringify(children)].filter(Boolean).join(\" \"), \"error\");\n  }\n\n  var floatingPositionStrategy = React.useMemo(function () {\n    return (target === null || target === void 0 ? void 0 : target.style.position) === \"fixed\" ? \"fixed\" : \"absolute\";\n  }, [target]);\n\n  if (process.env.NODE_ENV === \"development\" && target && !tooltipContainer) {\n    throw new Error(\"Use TooltipContainer for Tooltip outside Panel (see docs)\");\n  }\n\n  var memoizedMiddlewares = React.useMemo(function () {\n    var middlewares = [offsetMiddleware({\n      crossAxis: offsetX,\n      mainAxis: offsetY\n    })]; // см. https://floating-ui.com/docs/flip#conflict-with-autoplacement\n\n    if (isNotAutoPlacement) {\n      middlewares.push(flipMiddleware());\n    } else {\n      middlewares.push(autoPlacementMiddleware({\n        alignment: placement ? getAutoPlacementAlign(placement) : null\n      }));\n    }\n\n    middlewares.push(shiftMiddleware()); // см. https://floating-ui.com/docs/arrow#order\n\n    if (arrow) {\n      middlewares.push(arrowMiddleware({\n        element: arrowRef,\n        padding: arrowPadding\n      }));\n      middlewares.push({\n        name: \"arrowOffset\",\n        fn: function fn(param) {\n          var placement = param.placement,\n              middlewareData = param.middlewareData;\n\n          if (!middlewareData.arrow) {\n            return Promise.resolve({});\n          }\n\n          if (isVerticalPlacement(placement)) {\n            if (cornerAbsoluteOffset !== undefined) {\n              middlewareData.arrow.x = cornerAbsoluteOffset;\n            } else if (middlewareData.arrow.x !== undefined) {\n              middlewareData.arrow.x += cornerOffset;\n            }\n          } else {\n            if (cornerAbsoluteOffset !== undefined) {\n              middlewareData.arrow.y = cornerAbsoluteOffset;\n            } else if (middlewareData.arrow.y !== undefined) {\n              middlewareData.arrow.y += cornerOffset;\n            }\n          }\n\n          return Promise.resolve({});\n        }\n      });\n    }\n\n    return middlewares;\n  }, [arrow, arrowRef, arrowPadding, cornerAbsoluteOffset, cornerOffset, offsetX, offsetY, placement, isNotAutoPlacement]);\n\n  var _useFloating = useFloating({\n    strategy: floatingPositionStrategy,\n    placement: isNotAutoPlacement ? placement : undefined,\n    middleware: memoizedMiddlewares,\n    whileElementsMounted: autoUpdateFloatingElement\n  }),\n      floatingDataX = _useFloating.x,\n      floatingDataY = _useFloating.y,\n      resolvedPlacement = _useFloating.placement,\n      refs = _useFloating.refs,\n      _useFloating_middlewareData = _useFloating.middlewareData,\n      arrowCoords = _useFloating_middlewareData.arrow;\n\n  var childRef = isDOMTypeElement(children) ? children.ref : /*#__PURE__*/React.isValidElement(children) ? children.props.getRootRef : null;\n  var patchedRef = useExternRef(setTarget, refs.setReference, childRef);\n  var child = /*#__PURE__*/React.isValidElement(children) ? /*#__PURE__*/React.cloneElement(children, _define_property({}, isDOMTypeElement(children) ? \"ref\" : \"getRootRef\", patchedRef)) : children;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, child, isShown && target != null && /*#__PURE__*/ReactDOM.createPortal( /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(TooltipBase, _object_spread_props(_object_spread({}, restProps), {\n    getRootRef: refs.setFloating,\n    floatingStyle: convertFloatingDataToReactCSSProperties(floatingPositionStrategy, floatingDataX, floatingDataY),\n    withArrow: arrow,\n    arrowCoords: arrowCoords,\n    arrowPlacement: resolvedPlacement,\n    getArrowRef: setArrowRef,\n    maxWidth: maxWidth\n  })), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiTooltip__overlay\",\n    onClickCapture: onClose\n  })), tooltipContainer));\n};","map":{"version":3,"mappings":"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","names":["React","ReactDOM","hasReactNode","useExternRef","arrowMiddleware","autoPlacementMiddleware","autoUpdateFloatingElement","checkIsNotAutoPlacement","convertFloatingDataToReactCSSProperties","flipMiddleware","getAutoPlacementAlign","offsetMiddleware","shiftMiddleware","useFloating","warnOnce","useNavTransition","TOOLTIP_MAX_WIDTH","TooltipBase","tooltipContainerAttr","isDOMTypeElement","element","isValidElement","type","warn","mapAlignX","x","getDefaultPlacement","alignX","alignY","filter","p","join","isVerticalPlacement","placement","startsWith","Tooltip","children","isShownProp","isShown","offsetX","_param_offsetX","_param_offsetY","offsetY","onClose","cornerOffset","_param_cornerOffset","cornerAbsoluteOffset","arrow","_param_arrow","_param_arrowPadding","arrowPadding","placementProp","maxWidth","restProps","useState","arrowRef","setArrowRef","target","setTarget","tooltipContainer","useMemo","closest","concat","entering","isNotAutoPlacement","process","env","NODE_ENV","multiChildren","Children","count","primitiveChild","JSON","stringify","Boolean","floatingPositionStrategy","style","position","Error","memoizedMiddlewares","middlewares","crossAxis","mainAxis","push","alignment","padding","name","fn","param","middlewareData","Promise","resolve","undefined","y","strategy","middleware","whileElementsMounted","floatingDataX","floatingDataY","resolvedPlacement","refs","arrowCoords","childRef","ref","props","getRootRef","patchedRef","setReference","child","cloneElement","_define_property","Fragment","createPortal","setFloating","floatingStyle","withArrow","arrowPlacement","getArrowRef","div","className","onClickCapture"],"sources":["C:\\Users\\kulag\\vk\\Ability\\node_modules\\@vkontakte\\vkui\\src\\components\\Tooltip\\Tooltip.tsx"],"sourcesContent":["import * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { hasReactNode } from '@vkontakte/vkjs';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport {\n  arrowMiddleware,\n  autoPlacementMiddleware,\n  autoUpdateFloatingElement,\n  checkIsNotAutoPlacement,\n  convertFloatingDataToReactCSSProperties,\n  flipMiddleware,\n  getAutoPlacementAlign,\n  offsetMiddleware,\n  type Placement,\n  type PlacementWithAuto,\n  shiftMiddleware,\n  useFloating,\n  type UseFloatingMiddleware,\n} from '../../lib/floating';\nimport { warnOnce } from '../../lib/warnOnce';\nimport { HasRootRef } from '../../types';\nimport { useNavTransition } from '../NavTransitionContext/NavTransitionContext';\nimport { TOOLTIP_MAX_WIDTH, TooltipBase, type TooltipBaseProps } from '../TooltipBase/TooltipBase';\nimport { tooltipContainerAttr } from './TooltipContainer';\nimport styles from './Tooltip.module.css';\n\n/**\n * Перебиваем `ref`.\n *\n * В оригинальном `React.DOMElement` задаётся `React.LegacyRef<T>`, в котором есть `string`.\n * Когда как `{ ref: \"string\" }` уже давно депрекейтнут.\n */\ninterface DOMElement<P extends React.HTMLAttributes<T> | React.SVGAttributes<T>, T extends Element>\n  extends React.DOMElement<P, T> {\n  ref: React.Ref<T>;\n}\n\nconst isDOMTypeElement = <\n  P extends React.HTMLAttributes<T> | React.SVGAttributes<T>,\n  T extends Element,\n>(\n  element: React.ReactElement,\n): element is DOMElement<P, T> => {\n  return React.isValidElement(element) && typeof element.type === 'string';\n};\n\nconst warn = warnOnce('Tooltip');\n\nexport interface TooltipProps\n  extends Omit<\n    TooltipBaseProps,\n    'arrowCoords' | 'arrowPlacement' | 'getArrowRef' | 'floatingStyle' | 'withArrow'\n  > {\n  /**\n   * **Важно**: если в `children` передан React-компонент, то необходимо убедиться в том, что он поддерживает\n   * свойство `getRootRef`, которое должно возвращаться ссылку на корневой DOM-элемент компонента,\n   * иначе тултип показан не будет. Если передан React-element, то такой проблемы нет.\n   */\n  children: React.ReactElement<HasRootRef<any>> | React.ReactElement;\n  /**\n   * Если передан `false`, то рисуется просто `children`.\n   */\n  isShown?: boolean;\n  alignX?: 'center' | 'left' | 'right';\n  /**\n   * Положение по вертикали (расположение над или под `children`).\n   * Если не задано, позиция по вертикали определятся автоматически\n   */\n  alignY?: 'top' | 'bottom';\n  /**\n   * Сдвиг по горизонтали (относительно портала, в котором рисуется тултип).\n   */\n  offsetX?: number;\n  /**\n   * Сдвиг по вертикали (относительно портала, в котором рисуется тултип).\n   */\n  offsetY?: number;\n  /**\n   * Отображать ли стрелку, указывающую на якорный элемент\n   */\n  arrow?: boolean;\n  /**\n   * Безопасная зона вокруг стрелки, чтобы та не выходила за края контента.\n   */\n  arrowPadding?: number;\n  /**\n   * Сдвиг стрелочки относительно центра дочернего элемента.\n   */\n  cornerOffset?: number;\n  /**\n   * Сдвиг стрелочки относительно ширины тултипа\n   */\n  cornerAbsoluteOffset?: number;\n  /**\n   * Callback, который вызывается при клике по любому месту в пределах экрана.\n   */\n  onClose?: () => void;\n  /**\n   * По умолчанию компонент выберет наилучшее расположение сам. Но его можно задать извне с помощью этого свойства\n   */\n  placement?: PlacementWithAuto;\n}\n\nfunction mapAlignX(x: TooltipProps['alignX']) {\n  switch (x) {\n    case 'left':\n      return 'start';\n    case 'right':\n      return 'end';\n    default:\n      return '';\n  }\n}\nfunction getDefaultPlacement(\n  alignX: TooltipProps['alignX'],\n  alignY: TooltipProps['alignY'],\n): Placement {\n  return [alignY || 'bottom', mapAlignX(alignX || 'left')]\n    .filter((p) => !!p)\n    .join('-') as Placement;\n}\nfunction isVerticalPlacement(placement: PlacementWithAuto) {\n  return placement.startsWith('top') || placement.startsWith('bottom');\n}\n\n/**\n * @see https://vkcom.github.io/VKUI/#/Tooltip\n */\nexport const Tooltip = ({\n  children,\n  isShown: isShownProp = true,\n  offsetX = 0,\n  offsetY = 15,\n  alignX,\n  alignY,\n  onClose,\n  cornerOffset = 0,\n  cornerAbsoluteOffset,\n  arrow = true,\n  arrowPadding = 14,\n  placement: placementProp,\n  maxWidth = TOOLTIP_MAX_WIDTH,\n  ...restProps\n}: TooltipProps) => {\n  const [arrowRef, setArrowRef] = React.useState<HTMLDivElement | null>(null);\n  const [target, setTarget] = React.useState<HTMLElement | null>(null);\n  /* eslint-disable no-restricted-properties */\n  const tooltipContainer = React.useMemo(\n    () => target?.closest<HTMLDivElement>(`[${tooltipContainerAttr}]`),\n    [target],\n  );\n  const { entering } = useNavTransition();\n  const isShown = isShownProp && tooltipContainer && !entering;\n\n  const placement = placementProp || getDefaultPlacement(alignX, alignY);\n  const isNotAutoPlacement = checkIsNotAutoPlacement(placement);\n\n  if (process.env.NODE_ENV === 'development') {\n    const multiChildren = React.Children.count(children) > 1;\n    // Empty children is a noop\n    const primitiveChild = hasReactNode(children) && typeof children !== 'object';\n    (multiChildren || primitiveChild) &&\n      warn(\n        [\n          'children должен быть одним React элементом, получено',\n          multiChildren && 'несколько',\n          primitiveChild && JSON.stringify(children),\n        ]\n          .filter(Boolean)\n          .join(' '),\n        'error',\n      );\n  }\n\n  const floatingPositionStrategy = React.useMemo(\n    () => (target?.style.position === 'fixed' ? 'fixed' : 'absolute'),\n    [target],\n  );\n\n  if (process.env.NODE_ENV === 'development' && target && !tooltipContainer) {\n    throw new Error('Use TooltipContainer for Tooltip outside Panel (see docs)');\n  }\n\n  const memoizedMiddlewares = React.useMemo(() => {\n    const middlewares: UseFloatingMiddleware[] = [\n      offsetMiddleware({\n        crossAxis: offsetX,\n        mainAxis: offsetY,\n      }),\n    ];\n\n    // см. https://floating-ui.com/docs/flip#conflict-with-autoplacement\n    if (isNotAutoPlacement) {\n      middlewares.push(flipMiddleware());\n    } else {\n      middlewares.push(\n        autoPlacementMiddleware({\n          alignment: placement ? getAutoPlacementAlign(placement) : null,\n        }),\n      );\n    }\n\n    middlewares.push(shiftMiddleware());\n\n    // см. https://floating-ui.com/docs/arrow#order\n    if (arrow) {\n      middlewares.push(\n        arrowMiddleware({\n          element: arrowRef,\n          padding: arrowPadding,\n        }),\n      );\n      middlewares.push({\n        name: 'arrowOffset',\n        fn({ placement, middlewareData }) {\n          if (!middlewareData.arrow) {\n            return Promise.resolve({});\n          }\n          if (isVerticalPlacement(placement)) {\n            if (cornerAbsoluteOffset !== undefined) {\n              middlewareData.arrow.x = cornerAbsoluteOffset;\n            } else if (middlewareData.arrow.x !== undefined) {\n              middlewareData.arrow.x += cornerOffset;\n            }\n          } else {\n            if (cornerAbsoluteOffset !== undefined) {\n              middlewareData.arrow.y = cornerAbsoluteOffset;\n            } else if (middlewareData.arrow.y !== undefined) {\n              middlewareData.arrow.y += cornerOffset;\n            }\n          }\n          return Promise.resolve({});\n        },\n      });\n    }\n\n    return middlewares;\n  }, [\n    arrow,\n    arrowRef,\n    arrowPadding,\n    cornerAbsoluteOffset,\n    cornerOffset,\n    offsetX,\n    offsetY,\n    placement,\n    isNotAutoPlacement,\n  ]);\n\n  const {\n    x: floatingDataX,\n    y: floatingDataY,\n    placement: resolvedPlacement,\n    refs,\n    middlewareData: { arrow: arrowCoords },\n  } = useFloating({\n    strategy: floatingPositionStrategy,\n    placement: isNotAutoPlacement ? placement : undefined,\n    middleware: memoizedMiddlewares,\n    whileElementsMounted: autoUpdateFloatingElement,\n  });\n\n  const childRef = isDOMTypeElement<React.HTMLAttributes<HTMLElement>, HTMLElement>(children)\n    ? children.ref\n    : React.isValidElement<HasRootRef<HTMLElement>>(children)\n    ? children.props.getRootRef\n    : null;\n  const patchedRef = useExternRef<HTMLElement>(setTarget, refs.setReference, childRef);\n  const child = React.isValidElement(children)\n    ? React.cloneElement(children, {\n        [isDOMTypeElement(children) ? 'ref' : 'getRootRef']: patchedRef,\n      })\n    : children;\n\n  return (\n    <React.Fragment>\n      {child}\n      {isShown &&\n        target != null &&\n        ReactDOM.createPortal(\n          <>\n            <TooltipBase\n              {...restProps}\n              getRootRef={refs.setFloating}\n              floatingStyle={convertFloatingDataToReactCSSProperties(\n                floatingPositionStrategy,\n                floatingDataX,\n                floatingDataY,\n              )}\n              withArrow={arrow}\n              arrowCoords={arrowCoords}\n              arrowPlacement={resolvedPlacement}\n              getArrowRef={setArrowRef}\n              maxWidth={maxWidth}\n            />\n            <div className={styles['Tooltip__overlay']} onClickCapture={onClose} />\n          </>,\n          tooltipContainer,\n        )}\n    </React.Fragment>\n  );\n};\n"]},"metadata":{},"sourceType":"module"}