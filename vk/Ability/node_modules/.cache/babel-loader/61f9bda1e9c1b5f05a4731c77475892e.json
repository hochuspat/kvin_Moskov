{"ast":null,"code":"import { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\nimport { SLIDE_THRESHOLD } from \"./constants\";\n/*\n * Считает отступ слоя галереи\n */\n\nexport function calculateIndent(targetIndex, slidesManager, isCenterWithCustomWidth) {\n  if (slidesManager.isFullyVisible || !slidesManager.slides.length) {\n    return 0;\n  }\n\n  var targetSlide = slidesManager.slides[targetIndex];\n\n  if (targetSlide) {\n    var coordX = targetSlide.coordX,\n        width = targetSlide.width;\n\n    if (isCenterWithCustomWidth) {\n      return slidesManager.viewportOffsetWidth / 2 - coordX - width / 2;\n    }\n\n    return -1 * coordX;\n  }\n\n  return 0;\n}\n/**\n * Вычисляем индексы слайдов, которые необходимо смещать\n */\n\nexport function getShiftedIndexes(direction, slides, availableWidth) {\n  var gap = availableWidth;\n  var shiftedSlideIndexes = [];\n  var startIndex = direction === 1 ? 0 : slides.length - 1;\n  var endIndex = direction === 1 ? slides.length - 1 : 0;\n\n  for (var i = startIndex; (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0; i += direction) {\n    var slideWidth = slides[i].width;\n\n    if (gap > 0) {\n      shiftedSlideIndexes.push(i);\n    }\n\n    gap -= slideWidth;\n  }\n\n  return shiftedSlideIndexes;\n}\nexport function calculateLoopPoints(indexes, edge, slidesManager, containerWidth) {\n  var contentSize = slidesManager.contentSize,\n      slides = slidesManager.slides,\n      snaps = slidesManager.snaps;\n  var isStartEdge = edge === \"start\";\n  var offset = isStartEdge ? -contentSize : contentSize;\n  return indexes.map(function (index) {\n    var initial = isStartEdge ? 0 : -contentSize;\n    var altered = isStartEdge ? contentSize : 0;\n    var loopPoint = isStartEdge ? snaps[index] + containerWidth + offset : snaps[index] - slides[index].width + offset - snaps[0];\n    return {\n      index: index,\n      target: function (currentLocation) {\n        return currentLocation >= loopPoint ? initial : altered;\n      }\n    };\n  });\n}\n/**\n * Вычисляем \"ключевые\" точки, на которых должно происходить смещение слайдов\n */\n\nexport function getLoopPoints(slidesManager, containerWidth) {\n  var slides = slidesManager.slides,\n      snaps = slidesManager.snaps;\n  var startShiftedIndexes = getShiftedIndexes(-1, slides, snaps[0]);\n  var endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - snaps[0]);\n  return _to_consumable_array(calculateLoopPoints(endShiftedIndexes, \"start\", slidesManager, containerWidth)).concat(_to_consumable_array(calculateLoopPoints(startShiftedIndexes, \"end\", slidesManager, containerWidth)));\n}\n/*\n * Получает индекс слайда, к которому будет осуществлен переход\n */\n\nexport function getTargetIndex(slides, slideIndex, currentShiftX, currentShiftXDelta) {\n  var shift = currentShiftX + currentShiftXDelta;\n  var direction = currentShiftXDelta < 0 ? 1 : -1; // Находим ближайшую границу слайда к текущему отступу\n\n  var targetIndex = slides.reduce(function (val, item, index) {\n    var previousValue = Math.abs(slides[val].coordX + shift);\n    var currentValue = Math.abs(item.coordX + shift);\n    return previousValue < currentValue ? val : index;\n  }, slideIndex);\n\n  if (targetIndex === slideIndex) {\n    var targetSlide = slideIndex + direction;\n\n    if (targetSlide >= 0 && targetSlide < slides.length) {\n      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {\n        return targetSlide;\n      }\n\n      return targetIndex;\n    }\n\n    return direction < 0 ? (targetSlide + slides.length) % slides.length : targetSlide % slides.length;\n  }\n\n  return targetIndex;\n}","map":{"version":3,"mappings":"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","names":["SLIDE_THRESHOLD","calculateIndent","targetIndex","slidesManager","isCenterWithCustomWidth","isFullyVisible","slides","length","targetSlide","coordX","width","viewportOffsetWidth","getShiftedIndexes","direction","availableWidth","gap","shiftedSlideIndexes","startIndex","endIndex","i","slideWidth","push","calculateLoopPoints","indexes","edge","containerWidth","contentSize","snaps","isStartEdge","offset","map","index","initial","altered","loopPoint","target","currentLocation","getLoopPoints","startShiftedIndexes","endShiftedIndexes","_to_consumable_array","getTargetIndex","slideIndex","currentShiftX","currentShiftXDelta","shift","reduce","val","item","previousValue","Math","abs","currentValue"],"sources":["C:\\Users\\kulag\\vk\\Ability\\node_modules\\@vkontakte\\vkui\\src\\components\\BaseGallery\\CarouselBase\\helpers.ts"],"sourcesContent":["import { GallerySlidesState } from '../types';\nimport { SLIDE_THRESHOLD } from './constants';\nimport { LoopPoint, SlidesManagerState } from './types';\n\n/*\n * Считает отступ слоя галереи\n */\nexport function calculateIndent(\n  targetIndex: number,\n  slidesManager: SlidesManagerState,\n  isCenterWithCustomWidth: boolean,\n) {\n  if (slidesManager.isFullyVisible || !slidesManager.slides.length) {\n    return 0;\n  }\n\n  const targetSlide = slidesManager.slides[targetIndex];\n\n  if (targetSlide) {\n    const { coordX, width } = targetSlide;\n\n    if (isCenterWithCustomWidth) {\n      return slidesManager.viewportOffsetWidth / 2 - coordX - width / 2;\n    }\n\n    return -1 * coordX;\n  }\n\n  return 0;\n}\n\n/**\n * Вычисляем индексы слайдов, которые необходимо смещать\n */\nexport function getShiftedIndexes(\n  direction: 1 | -1,\n  slides: GallerySlidesState[],\n  availableWidth: number,\n) {\n  let gap = availableWidth;\n  const shiftedSlideIndexes = [];\n  const startIndex = direction === 1 ? 0 : slides.length - 1;\n  const endIndex = direction === 1 ? slides.length - 1 : 0;\n\n  for (\n    let i = startIndex;\n    (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0;\n    i += direction\n  ) {\n    const slideWidth = slides[i].width;\n\n    if (gap > 0) {\n      shiftedSlideIndexes.push(i);\n    }\n    gap -= slideWidth;\n  }\n\n  return shiftedSlideIndexes;\n}\n\nexport function calculateLoopPoints(\n  indexes: number[],\n  edge: 'start' | 'end',\n  slidesManager: SlidesManagerState,\n  containerWidth: number,\n): LoopPoint[] {\n  const { contentSize, slides, snaps } = slidesManager;\n  const isStartEdge = edge === 'start';\n  const offset = isStartEdge ? -contentSize : contentSize;\n\n  return indexes.map((index) => {\n    const initial = isStartEdge ? 0 : -contentSize;\n    const altered = isStartEdge ? contentSize : 0;\n    const loopPoint = isStartEdge\n      ? snaps[index] + containerWidth + offset\n      : snaps[index] - slides[index].width + offset - snaps[0];\n\n    return {\n      index,\n      target: (currentLocation) => {\n        return currentLocation >= loopPoint ? initial : altered;\n      },\n    };\n  });\n}\n\n/**\n * Вычисляем \"ключевые\" точки, на которых должно происходить смещение слайдов\n */\nexport function getLoopPoints(slidesManager: SlidesManagerState, containerWidth: number) {\n  const { slides, snaps } = slidesManager;\n  const startShiftedIndexes = getShiftedIndexes(-1, slides, snaps[0]);\n  const endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - snaps[0]);\n\n  return [\n    ...calculateLoopPoints(endShiftedIndexes, 'start', slidesManager, containerWidth),\n    ...calculateLoopPoints(startShiftedIndexes, 'end', slidesManager, containerWidth),\n  ];\n}\n\n/*\n * Получает индекс слайда, к которому будет осуществлен переход\n */\nexport function getTargetIndex(\n  slides: GallerySlidesState[],\n  slideIndex: number,\n  currentShiftX: number,\n  currentShiftXDelta: number,\n) {\n  const shift = currentShiftX + currentShiftXDelta;\n  const direction = currentShiftXDelta < 0 ? 1 : -1;\n\n  // Находим ближайшую границу слайда к текущему отступу\n  let targetIndex = slides.reduce((val: number, item: GallerySlidesState, index: number) => {\n    const previousValue = Math.abs(slides[val].coordX + shift);\n    const currentValue = Math.abs(item.coordX + shift);\n\n    return previousValue < currentValue ? val : index;\n  }, slideIndex);\n\n  if (targetIndex === slideIndex) {\n    let targetSlide = slideIndex + direction;\n\n    if (targetSlide >= 0 && targetSlide < slides.length) {\n      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {\n        return targetSlide;\n      }\n      return targetIndex;\n    }\n    return direction < 0\n      ? (targetSlide + slides.length) % slides.length\n      : targetSlide % slides.length;\n  }\n\n  return targetIndex;\n}\n"]},"metadata":{},"sourceType":"module"}