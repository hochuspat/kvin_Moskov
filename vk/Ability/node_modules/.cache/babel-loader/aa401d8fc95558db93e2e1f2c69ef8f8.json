{"ast":null,"code":"import { _ as _assert_this_initialized } from \"@swc/helpers/_/_assert_this_initialized\";\nimport { _ as _class_call_check } from \"@swc/helpers/_/_class_call_check\";\nimport { _ as _create_class } from \"@swc/helpers/_/_create_class\";\nimport { _ as _define_property } from \"@swc/helpers/_/_define_property\";\nimport { _ as _inherits } from \"@swc/helpers/_/_inherits\";\nimport { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _to_consumable_array } from \"@swc/helpers/_/_to_consumable_array\";\nimport { _ as _create_super } from \"@swc/helpers/_/_create_super\";\nimport * as React from \"react\";\nimport { classNames } from \"@vkontakte/vkjs\";\nimport { withContext } from \"../../hoc/withContext\";\nimport { withPlatform } from \"../../hoc/withPlatform\";\nimport { canUseDOM, withDOM } from \"../../lib/dom\";\nimport { getNavId } from \"../../lib/getNavId\";\nimport { Platform } from \"../../lib/platform\";\nimport { animationEvent, transitionEvent } from \"../../lib/supportEvents\";\nimport { warnOnce } from \"../../lib/warnOnce\";\nimport { ScrollContext } from \"../AppRoot/ScrollContext\";\nimport { ConfigProviderContext } from \"../ConfigProvider/ConfigProviderContext\";\nimport { NavViewIdContext } from \"../NavIdContext/NavIdContext\";\nimport { NavTransitionProvider } from \"../NavTransitionContext/NavTransitionContext\";\nimport { NavTransitionDirectionProvider } from \"../NavTransitionDirectionContext/NavTransitionDirectionContext\";\nimport { SplitColContext } from \"../SplitCol/SplitColContext\";\nimport { Touch } from \"../Touch/Touch\";\nimport { getSwipeBackPredicates, hasHorizontalScrollableElementWithScrolledToLeft, swipeBackExcluded } from \"./utils\";\nvar warn = warnOnce(\"ViewInfinite\");\nvar SwipeBackResults;\n\n(function (SwipeBackResults) {\n  SwipeBackResults[SwipeBackResults[\"fail\"] = 1] = \"fail\";\n  SwipeBackResults[SwipeBackResults[\"success\"] = 2] = \"success\";\n})(SwipeBackResults || (SwipeBackResults = {}));\n\nexport var scrollsCache = {};\n\nvar _React_Component;\n\nvar ViewInfiniteComponent = /*#__PURE__*/function (_superClass) {\n  \"use strict\";\n\n  _inherits(ViewInfiniteComponent, _superClass);\n\n  var _super = _create_super(ViewInfiniteComponent);\n\n  function ViewInfiniteComponent(props) {\n    _class_call_check(this, ViewInfiniteComponent);\n\n    var _this;\n\n    _this = _super.call(this, props);\n\n    _define_property(_assert_this_initialized(_this), \"swipeBackPrevented\", false);\n\n    _define_property(_assert_this_initialized(_this), \"scrolls\", scrollsCache[getNavId(_this.props, warn)] || {});\n\n    _define_property(_assert_this_initialized(_this), \"transitionFinishTimeout\", undefined);\n\n    _define_property(_assert_this_initialized(_this), \"animationFinishTimeout\", undefined);\n\n    _define_property(_assert_this_initialized(_this), \"panelNodes\", {});\n\n    _define_property(_assert_this_initialized(_this), \"transitionEndHandler\", function (e) {\n      if ((!e || [\"vkuianimation-ios-next-forward\", \"vkuianimation-ios-prev-back\", \"vkuianimation-view-next-forward\", \"vkuianimation-view-prev-back\"].includes(e.animationName)) && _this.state.prevPanel !== null) {\n        _this.flushTransition(_this.state.prevPanel, Boolean(_this.state.isBack));\n      }\n    });\n\n    _define_property(_assert_this_initialized(_this), \"swipingBackTransitionEndHandler\", function (e) {\n      // indexOf because of vendor prefixes in old browsers\n      if (!e || e.propertyName.includes(\"transform\") && e.target === _this.pickPanel(_this.state.swipeBackNextPanel)) {\n        switch (_this.state.swipeBackResult) {\n          case 1:\n            _this.onSwipeBackCancel();\n\n            break;\n\n          case 2:\n            _this.onSwipeBackSuccess();\n\n        }\n      }\n    });\n\n    _define_property(_assert_this_initialized(_this), \"handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext\", function (event) {\n      if (_this.state.browserSwipe) {\n        return;\n      }\n\n      var _getSwipeBackPredicates = getSwipeBackPredicates(event.startX, event.shiftX, _this.window.innerWidth),\n          swipeBackTriggered = _getSwipeBackPredicates.swipeBackTriggered,\n          viewportStartEdgeTouched = _getSwipeBackPredicates.viewportStartEdgeTouched,\n          viewportEndEdgeTouched = _getSwipeBackPredicates.viewportEndEdgeTouched;\n\n      if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {\n        _this.setState({\n          browserSwipe: true\n        });\n      }\n    });\n\n    _define_property(_assert_this_initialized(_this), \"handleTouchMoveXForIOSSwipeBackSimulation\", function (event) {\n      if (_this.swipeBackPrevented || swipeBackExcluded(event)) {\n        return;\n      }\n\n      var _getSwipeBackPredicates = getSwipeBackPredicates(event.startX, event.shiftX, _this.window.innerWidth),\n          swipedToOpposite = _getSwipeBackPredicates.swipedToOpposite,\n          swipeBackTriggered = _getSwipeBackPredicates.swipeBackTriggered,\n          viewportStartEdgeTouched = _getSwipeBackPredicates.viewportStartEdgeTouched;\n\n      if (_this.state.animated && swipeBackTriggered) {\n        return;\n      }\n\n      if (!_this.state.swipingBack && _this.props.history && _this.props.history.length > 1) {\n        if (swipedToOpposite) {\n          _this.swipeBackPrevented = true;\n          return;\n        }\n\n        if (!swipeBackTriggered) {\n          return;\n        }\n\n        if (!viewportStartEdgeTouched && hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target)) {\n          _this.swipeBackPrevented = true;\n          return;\n        } // Начался свайп назад\n\n\n        if (_this.props.onSwipeBackStart) {\n          var payload = _this.props.onSwipeBackStart(_this.state.activePanel);\n\n          if (payload === \"prevent\") {\n            _this.swipeBackPrevented = true;\n            return;\n          }\n        }\n\n        if (_this.state.activePanel !== null) {\n          var _this_props_scroll; // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n\n\n          _this.blurActiveElement();\n\n          var prevScrolls = _this.scrolls[_this.state.activePanel] || [];\n          _this.scrolls = _object_spread_props(_object_spread({}, _this.scrolls), _define_property({}, _this.state.activePanel, _to_consumable_array(prevScrolls).concat([(_this_props_scroll = _this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll().y])));\n        }\n\n        _this.setState({\n          swipingBack: true,\n          swipeBackStartX: event.startX,\n          swipeBackPrevPanel: _this.state.activePanel,\n          swipeBackNextPanel: _this.props.history.slice(-2)[0]\n        });\n      }\n\n      if (_this.state.swipingBack) {\n        if (event.shiftX < 0) {\n          _this.setState({\n            swipeBackShift: 0\n          });\n        } else if (event.shiftX > _this.window.innerWidth - _this.state.swipeBackStartX) {\n          _this.setState({\n            swipeBackShift: _this.window.innerWidth\n          });\n        } else {\n          _this.setState({\n            swipeBackShift: event.shiftX\n          });\n        }\n      }\n    });\n\n    _define_property(_assert_this_initialized(_this), \"handleTouchEndForIOSSwipeBackSimulation\", function (event) {\n      _this.swipeBackPrevented = false;\n\n      if (_this.state.swipingBack && _this.window) {\n        var speed = _this.state.swipeBackShift / event.duration * 1000;\n\n        if (_this.state.swipeBackShift === 0) {\n          _this.onSwipeBackCancel();\n        } else if (_this.state.swipeBackShift >= _this.window.innerWidth) {\n          _this.onSwipeBackSuccess();\n        } else if (speed > 250 || _this.state.swipeBackShift >= _this.window.innerWidth / 2) {\n          _this.setState({\n            swipeBackResult: 2\n          });\n        } else {\n          _this.setState({\n            swipeBackResult: 1\n          });\n        }\n      }\n    });\n\n    _this.state = {\n      animated: false,\n      visiblePanels: [props.activePanel],\n      activePanel: props.activePanel,\n      isBack: undefined,\n      prevPanel: null,\n      nextPanel: null,\n      swipingBack: undefined,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n      swipeBackNextPanel: null,\n      swipeBackPrevPanel: null,\n      swipeBackResult: null,\n      browserSwipe: false\n    };\n    return _this;\n  }\n\n  _create_class(ViewInfiniteComponent, [{\n    key: \"document\",\n    get: function get() {\n      return this.props.document;\n    }\n  }, {\n    key: \"window\",\n    get: function get() {\n      return this.props.window;\n    }\n  }, {\n    key: \"panels\",\n    get: function get() {\n      return React.Children.toArray(this.props.children);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      var id = getNavId(this.props);\n\n      if (id) {\n        scrollsCache[id] = this.scrolls;\n      }\n\n      if (this.animationFinishTimeout) {\n        clearTimeout(this.animationFinishTimeout);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps, prevState) {\n      var _this = this; // Нужен переход\n\n\n      if (prevProps.activePanel !== this.props.activePanel && !prevState.swipingBack && !prevState.browserSwipe) {\n        var _this_props_scroll;\n\n        var isBack = false;\n\n        if (this.props.isBackCheck) {\n          isBack = this.props.isBackCheck({\n            from: prevProps.activePanel,\n            to: this.props.activePanel\n          });\n        } else {\n          var firstLayerId = this.panels.map(function (panel) {\n            return getNavId(panel.props, warn);\n          }).find(function (id) {\n            return id === prevProps.activePanel || id === _this.props.activePanel;\n          });\n          isBack = firstLayerId === this.props.activePanel;\n        }\n\n        this.blurActiveElement();\n        var prevScrolls = this.scrolls[prevProps.activePanel] || [];\n\n        var scrolls = _object_spread_props(_object_spread({}, this.scrolls), _define_property({}, prevProps.activePanel, _to_consumable_array(prevScrolls).concat([(_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll().y])));\n\n        this.scrolls = scrolls;\n\n        if (this.shouldDisableTransitionMotion()) {\n          this.flushTransition(prevProps.activePanel, isBack);\n        } else {\n          this.setState({\n            visiblePanels: [prevProps.activePanel, this.props.activePanel],\n            prevPanel: prevProps.activePanel,\n            nextPanel: this.props.activePanel,\n            activePanel: null,\n            animated: true,\n            isBack: isBack\n          }); // Фолбек анимации перехода\n\n          if (!animationEvent.supported) {\n            if (this.animationFinishTimeout) {\n              clearTimeout(this.animationFinishTimeout);\n            }\n\n            this.animationFinishTimeout = setTimeout(this.transitionEndHandler, this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM ? 300 : 600);\n          }\n        }\n      } // Закончилась анимация свайпа назад\n\n\n      if (prevProps.activePanel !== this.props.activePanel && prevState.swipingBack) {\n        var nextPanel = this.state.swipeBackNextPanel;\n        var prevPanel = this.state.swipeBackPrevPanel;\n        var scrollPosition = undefined;\n        this.scrolls = _object_spread({}, this.scrolls);\n\n        if (prevPanel !== null) {\n          var prevPanelScrolls = _to_consumable_array(this.scrolls[prevPanel] || []).slice(0, -1);\n\n          this.scrolls[prevPanel] = prevPanelScrolls;\n        }\n\n        if (nextPanel !== null) {\n          var newPanelScrolls = _to_consumable_array(this.scrolls[nextPanel] || []);\n\n          scrollPosition = newPanelScrolls.pop();\n          this.scrolls[nextPanel] = newPanelScrolls;\n        }\n\n        this.setState({\n          swipeBackPrevPanel: null,\n          swipeBackNextPanel: null,\n          swipingBack: false,\n          swipeBackResult: null,\n          swipeBackStartX: 0,\n          swipeBackShift: 0,\n          activePanel: nextPanel,\n          visiblePanels: [nextPanel]\n        }, function () {\n          var _this_props_scroll;\n\n          (_this_props_scroll = _this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.scrollTo(0, scrollPosition);\n          prevProps.onTransition && prevProps.onTransition({\n            isBack: true,\n            from: prevPanel,\n            to: nextPanel\n          });\n        });\n      } // Началась анимация завершения свайпа назад.\n\n\n      if (!prevState.swipeBackResult && this.state.swipeBackResult) {\n        this.waitTransitionFinish(this.pickPanel(this.state.swipeBackNextPanel), this.swipingBackTransitionEndHandler);\n      } // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n\n\n      if (prevState.swipeBackResult === 1 && !this.state.swipeBackResult && this.state.activePanel !== null) {\n        var _this_props_scroll1;\n\n        var newPanelScrolls1 = _to_consumable_array(this.scrolls[this.state.activePanel] || []);\n\n        var scrollPosition1 = newPanelScrolls1.pop();\n        this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), _define_property({}, this.state.activePanel, newPanelScrolls1));\n        (_this_props_scroll1 = this.props.scroll) === null || _this_props_scroll1 === void 0 ? void 0 : _this_props_scroll1.scrollTo(0, scrollPosition1);\n      } // Закончился Safari свайп\n\n\n      if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {\n        this.setState({\n          browserSwipe: false,\n          nextPanel: null,\n          prevPanel: null,\n          animated: false,\n          visiblePanels: [this.props.activePanel],\n          activePanel: this.props.activePanel\n        });\n      }\n    }\n  }, {\n    key: \"shouldDisableTransitionMotion\",\n    value: function shouldDisableTransitionMotion() {\n      var _this_props_configProvider, _this_props_splitCol;\n\n      return ((_this_props_configProvider = this.props.configProvider) === null || _this_props_configProvider === void 0 ? void 0 : _this_props_configProvider.transitionMotionEnabled) === false || !((_this_props_splitCol = this.props.splitCol) === null || _this_props_splitCol === void 0 ? void 0 : _this_props_splitCol.animate) || this.props.platform === Platform.VKCOM;\n    }\n  }, {\n    key: \"waitTransitionFinish\",\n    value: function waitTransitionFinish(elem, eventHandler) {\n      if (transitionEvent.supported && transitionEvent.name && elem) {\n        elem.removeEventListener(transitionEvent.name, eventHandler);\n        elem.addEventListener(transitionEvent.name, eventHandler);\n      } else {\n        if (this.transitionFinishTimeout) {\n          clearTimeout(this.transitionFinishTimeout);\n        }\n\n        this.transitionFinishTimeout = setTimeout(eventHandler, this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM ? 300 : 600);\n      }\n    }\n  }, {\n    key: \"blurActiveElement\",\n    value: function blurActiveElement() {\n      var _this_document;\n\n      if (typeof this.window !== \"undefined\" && ((_this_document = this.document) === null || _this_document === void 0 ? void 0 : _this_document.activeElement)) {\n        this.document.activeElement.blur();\n      }\n    }\n  }, {\n    key: \"pickPanel\",\n    value: function pickPanel(id) {\n      if (id === null) {\n        return undefined;\n      }\n\n      return this.panelNodes[id];\n    }\n  }, {\n    key: \"flushTransition\",\n    value: function flushTransition(prevPanel, isBack) {\n      var _this = this;\n\n      var activePanel = this.props.activePanel;\n\n      var prevPanelScrolls = _to_consumable_array(this.scrolls[prevPanel] || []).slice(0, -1);\n\n      var newPanelScrolls = _to_consumable_array(this.scrolls[activePanel] || []);\n\n      var scrollPosition = isBack ? newPanelScrolls.pop() : 0;\n\n      if (isBack) {\n        var _obj;\n\n        this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), (_obj = {}, _define_property(_obj, prevPanel, prevPanelScrolls), _define_property(_obj, activePanel, newPanelScrolls), _obj));\n      }\n\n      this.setState({\n        prevPanel: null,\n        nextPanel: null,\n        visiblePanels: [activePanel],\n        activePanel: activePanel,\n        animated: false,\n        isBack: isBack\n      }, function () {\n        var _this_props_scroll;\n\n        (_this_props_scroll = _this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.scrollTo(0, isBack ? scrollPosition : 0);\n        _this.props.onTransition && _this.props.onTransition({\n          isBack: isBack,\n          from: prevPanel,\n          to: activePanel\n        });\n      });\n    }\n  }, {\n    key: \"onSwipeBackSuccess\",\n    value: function onSwipeBackSuccess() {\n      this.props.onSwipeBack && this.props.onSwipeBack();\n    }\n  }, {\n    key: \"onSwipeBackCancel\",\n    value: function onSwipeBackCancel() {\n      this.props.onSwipeBackCancel && this.props.onSwipeBackCancel();\n      this.setState({\n        swipeBackPrevPanel: null,\n        swipeBackNextPanel: null,\n        swipingBack: false,\n        swipeBackResult: null,\n        swipeBackStartX: 0,\n        swipeBackShift: 0\n      });\n    }\n  }, {\n    key: \"calcPanelSwipeStyles\",\n    value: function calcPanelSwipeStyles(panelId) {\n      if (!canUseDOM || !this.window) {\n        return {};\n      }\n\n      var isPrev = panelId === this.state.swipeBackPrevPanel;\n      var isNext = panelId === this.state.swipeBackNextPanel;\n\n      if (!isPrev && !isNext || this.state.swipeBackResult) {\n        return {};\n      }\n\n      var prevPanelTranslate = \"\".concat(this.state.swipeBackShift, \"px\");\n      var nextPanelTranslate = \"\".concat(-50 + this.state.swipeBackShift * 100 / this.window.innerWidth / 2, \"%\");\n      var prevPanelShadow = 0.3 * (this.window.innerWidth - this.state.swipeBackShift) / this.window.innerWidth;\n\n      if (this.state.swipeBackResult) {\n        return isPrev ? {\n          boxShadow: \"-2px 0 12px rgba(0, 0, 0, \".concat(prevPanelShadow, \")\")\n        } : {};\n      }\n\n      if (isNext) {\n        return {\n          transform: \"translate3d(\".concat(nextPanelTranslate, \", 0, 0)\"),\n          WebkitTransform: \"translate3d(\".concat(nextPanelTranslate, \", 0, 0)\")\n        };\n      }\n\n      if (isPrev) {\n        return {\n          transform: \"translate3d(\".concat(prevPanelTranslate, \", 0, 0)\"),\n          WebkitTransform: \"translate3d(\".concat(prevPanelTranslate, \", 0, 0)\"),\n          boxShadow: \"-2px 0 12px rgba(0, 0, 0, \".concat(prevPanelShadow, \")\")\n        };\n      }\n\n      return {};\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      var _this_props = this.props,\n          platform = _this_props.platform,\n          _1 = _this_props.activePanel,\n          splitCol = _this_props.splitCol,\n          configProvider = _this_props.configProvider,\n          history = _this_props.history,\n          id = _this_props.id,\n          nav = _this_props.nav,\n          onTransition = _this_props.onTransition,\n          onSwipeBack = _this_props.onSwipeBack,\n          onSwipeBackStart = _this_props.onSwipeBackStart,\n          onSwipeBackCancel = _this_props.onSwipeBackCancel,\n          window = _this_props.window,\n          document = _this_props.document,\n          scroll = _this_props.scroll,\n          isBackCheck = _this_props.isBackCheck,\n          className = _this_props.className,\n          restProps = _object_without_properties(_this_props, [\"platform\", \"activePanel\", \"splitCol\", \"configProvider\", \"history\", \"id\", \"nav\", \"onTransition\", \"onSwipeBack\", \"onSwipeBackStart\", \"onSwipeBackCancel\", \"window\", \"document\", \"scroll\", \"isBackCheck\", \"className\"]);\n\n      var _this_state = this.state,\n          prevPanel = _this_state.prevPanel,\n          nextPanel = _this_state.nextPanel,\n          activePanel = _this_state.activePanel,\n          isBack = _this_state.isBack,\n          animated = _this_state.animated,\n          swipeBackPrevPanel = _this_state.swipeBackPrevPanel,\n          swipeBackNextPanel = _this_state.swipeBackNextPanel,\n          swipeBackResult = _this_state.swipeBackResult,\n          swipingBack = _this_state.swipingBack;\n      var panels = this.panels.filter(function (panel) {\n        var panelId = getNavId(panel.props, warn);\n        return panelId !== undefined && _this.state.visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;\n      }).sort(function (panel) {\n        var panelId = getNavId(panel.props, warn);\n        var isPrevPanel = panelId === prevPanel || panelId === swipeBackPrevPanel;\n        var isNextPanel = panelId === nextPanel || panelId === swipeBackNextPanel;\n\n        if (isNextPanel) {\n          return swipingBack || _this.state.isBack ? -1 : 1;\n        }\n\n        if (isPrevPanel) {\n          return swipingBack || _this.state.isBack ? 1 : -1;\n        }\n\n        return 0;\n      });\n      var disableAnimation = this.shouldDisableTransitionMotion();\n      var iOSSwipeBackSimulationEnabled = !disableAnimation && platform === Platform.IOS && (configProvider === null || configProvider === void 0 ? void 0 : configProvider.isWebView) && Boolean(onSwipeBack);\n      return /*#__PURE__*/React.createElement(NavViewIdContext.Provider, {\n        value: id || nav\n      }, /*#__PURE__*/React.createElement(Touch, _object_spread_props(_object_spread({\n        Component: \"section\"\n      }, restProps), {\n        className: classNames(\"vkuiView\", platform === Platform.IOS && classNames(\"vkuiView--ios\", \"vkuiInternalView--ios\"), !disableAnimation && this.state.animated && \"vkuiView--animated\", !disableAnimation && this.state.swipingBack && \"vkuiView--swiping-back\", disableAnimation && \"vkuiView--no-motion\", className),\n        onMoveX: iOSSwipeBackSimulationEnabled ? this.handleTouchMoveXForIOSSwipeBackSimulation : platform === Platform.IOS ? this.handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext : undefined,\n        onEnd: iOSSwipeBackSimulationEnabled ? this.handleTouchEndForIOSSwipeBackSimulation : undefined\n      }), /*#__PURE__*/React.createElement(\"div\", {\n        className: \"vkuiView__panels\"\n      }, panels.map(function (panel) {\n        var panelId = getNavId(panel.props, warn);\n        var isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;\n        var compensateScroll = isPrev || panelId === swipeBackNextPanel || panelId === nextPanel && isBack;\n        var isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);\n        var scrollList = panelId && _this.scrolls[panelId] || [];\n        var scroll = scrollList[scrollList.length - 1] || 0;\n        return /*#__PURE__*/React.createElement(\"div\", {\n          className: classNames(\"vkuiView__panel\", panelId === activePanel && \"vkuiView__panel--active\", panelId === prevPanel && \"vkuiView__panel--prev\", panelId === nextPanel && \"vkuiView__panel--next\", panelId === swipeBackPrevPanel && \"vkuiView__panel--swipe-back-prev\", panelId === swipeBackNextPanel && \"vkuiView__panel--swipe-back-next\", swipeBackResult === 2 && \"vkuiView__panel--swipe-back-success\", swipeBackResult === 1 && \"vkuiView__panel--swipe-back-failed\"),\n          onAnimationEnd: isTransitionTarget ? _this.transitionEndHandler : undefined,\n          ref: function (el) {\n            return panelId !== undefined && (_this.panelNodes[panelId] = el);\n          },\n          style: _this.calcPanelSwipeStyles(panelId),\n          key: panelId\n        }, /*#__PURE__*/React.createElement(\"div\", {\n          className: \"vkuiView__panel-in\",\n          style: {\n            marginTop: compensateScroll ? -scroll : undefined\n          }\n        }, /*#__PURE__*/React.createElement(NavTransitionDirectionProvider, {\n          isBack: swipingBack || isBack\n        }, /*#__PURE__*/React.createElement(NavTransitionProvider, {\n          entering: panelId === nextPanel || panelId === swipeBackNextPanel\n        }, panel))));\n      }))));\n    }\n  }]);\n\n  return ViewInfiniteComponent;\n}(_React_Component = React.Component);\n\n_define_property(ViewInfiniteComponent, \"defaultProps\", {\n  history: []\n});\n\nexport var ViewInfinite = withContext(withContext(withContext(withPlatform(withDOM(ViewInfiniteComponent)), SplitColContext, \"splitCol\"), ConfigProviderContext, \"configProvider\"), ScrollContext, \"scroll\");","map":{"version":3,"mappings":"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","names":["React","classNames","withContext","withPlatform","canUseDOM","withDOM","getNavId","Platform","animationEvent","transitionEvent","warnOnce","ScrollContext","ConfigProviderContext","NavViewIdContext","NavTransitionProvider","NavTransitionDirectionProvider","SplitColContext","Touch","getSwipeBackPredicates","hasHorizontalScrollableElementWithScrolledToLeft","swipeBackExcluded","warn","SwipeBackResults","scrollsCache","ViewInfiniteComponent","_superClass","props","_define_property","swipeBackPrevented","scrolls","_this","transitionFinishTimeout","undefined","animationFinishTimeout","panelNodes","transitionEndHandler","e","includes","animationName","state","prevPanel","flushTransition","Boolean","isBack","swipingBackTransitionEndHandler","propertyName","target","pickPanel","swipeBackNextPanel","swipeBackResult","onSwipeBackCancel","onSwipeBackSuccess","handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext","event","browserSwipe","startX","shiftX","window","innerWidth","swipeBackTriggered","viewportStartEdgeTouched","viewportEndEdgeTouched","setState","handleTouchMoveXForIOSSwipeBackSimulation","swipedToOpposite","animated","swipingBack","history","length","originalEvent","onSwipeBackStart","payload","activePanel","_this_props_scroll","blurActiveElement","prevScrolls","_object_spread_props","_to_consumable_array","scroll","getScroll","y","swipeBackStartX","swipeBackPrevPanel","slice","swipeBackShift","handleTouchEndForIOSSwipeBackSimulation","speed","duration","visiblePanels","nextPanel","document","panels","Children","toArray","children","componentWillUnmount","id","clearTimeout","componentDidUpdate","prevProps","prevState","isBackCheck","from","to","firstLayerId","map","panel","find","shouldDisableTransitionMotion","supported","setTimeout","platform","ANDROID","VKCOM","scrollPosition","_object_spread","prevPanelScrolls","newPanelScrolls","pop","scrollTo","onTransition","waitTransitionFinish","_this_props_scroll1","_this_props_configProvider","_this_props_splitCol","configProvider","transitionMotionEnabled","splitCol","animate","elem","eventHandler","name","removeEventListener","addEventListener","_this_document","activeElement","blur","_obj","onSwipeBack","calcPanelSwipeStyles","panelId","isPrev","isNext","prevPanelTranslate","concat","nextPanelTranslate","prevPanelShadow","boxShadow","transform","WebkitTransform","render","_this_props","_1","nav","className","restProps","_this_state","filter","sort","isPrevPanel","isNextPanel","disableAnimation","iOSSwipeBackSimulationEnabled","IOS","isWebView","Provider","value","Component","onMoveX","onEnd","div","compensateScroll","isTransitionTarget","scrollList","onAnimationEnd","ref","el","style","key","marginTop","entering","defaultProps","ViewInfinite"],"sources":["C:\\Users\\kulag\\vk\\Ability\\node_modules\\@vkontakte\\vkui\\src\\components\\View\\ViewInfinite.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { withContext } from '../../hoc/withContext';\nimport { withPlatform } from '../../hoc/withPlatform';\nimport { canUseDOM, DOMProps, withDOM } from '../../lib/dom';\nimport { getNavId, NavIdProps } from '../../lib/getNavId';\nimport { Platform } from '../../lib/platform';\nimport { animationEvent, transitionEvent } from '../../lib/supportEvents';\nimport { warnOnce } from '../../lib/warnOnce';\nimport { HasPlatform, HTMLAttributesWithRootRef } from '../../types';\nimport { ScrollContext, ScrollContextInterface } from '../AppRoot/ScrollContext';\nimport {\n  ConfigProviderContext,\n  ConfigProviderContextInterface,\n} from '../ConfigProvider/ConfigProviderContext';\nimport { NavViewIdContext } from '../NavIdContext/NavIdContext';\nimport { NavTransitionProvider } from '../NavTransitionContext/NavTransitionContext';\nimport { NavTransitionDirectionProvider } from '../NavTransitionDirectionContext/NavTransitionDirectionContext';\nimport { SplitColContext, SplitColContextProps } from '../SplitCol/SplitColContext';\nimport { Touch, TouchEvent } from '../Touch/Touch';\nimport {\n  getSwipeBackPredicates,\n  hasHorizontalScrollableElementWithScrolledToLeft,\n  swipeBackExcluded,\n} from './utils';\nimport styles from './View.module.css';\n\nconst warn = warnOnce('ViewInfinite');\n\nenum SwipeBackResults {\n  fail = 1,\n  success,\n}\n\ninterface Scrolls {\n  [index: string]: Array<number | undefined>;\n}\n\ninterface ViewsScrolls {\n  [index: string]: Scrolls;\n}\n\ntype TransitionEventHandler = (e?: TransitionEvent) => void;\n\nexport let scrollsCache: ViewsScrolls = {};\n\nexport type TransitionParams = { from: string | null; to: string | null };\n\nexport interface ViewInfiniteProps\n  extends HTMLAttributesWithRootRef<HTMLElement>,\n    HasPlatform,\n    NavIdProps {\n  activePanel: string;\n  onTransition?(params: TransitionParams & { isBack: boolean }): void;\n  /**\n   * callback свайпа назад\n   */\n  onSwipeBack?(): void;\n  /**\n   * callback начала анимации свайпа назад.\n   */\n  onSwipeBackStart?(activePanel: string | null): void | 'prevent';\n  /**\n   * callback завершения анимации отмененного пользователем свайпа\n   */\n  onSwipeBackCancel?(): void;\n  history?: string[];\n  isBackCheck?(params: TransitionParams): boolean;\n  /**\n   * @ignore\n   */\n  splitCol?: SplitColContextProps;\n  /**\n   * @ignore\n   */\n  configProvider?: ConfigProviderContextInterface;\n  /**\n   * @ignore\n   */\n  scroll?: ScrollContextInterface;\n}\n\nexport interface ViewInfiniteState {\n  animated: boolean;\n\n  visiblePanels: Array<string | null>;\n  activePanel: string | null;\n  isBack?: boolean;\n  prevPanel: string | null;\n  nextPanel: string | null;\n\n  swipingBack?: boolean;\n  swipeBackStartX: number;\n  swipeBackShift: number;\n  swipeBackNextPanel: string | null;\n  swipeBackPrevPanel: string | null;\n  swipeBackResult: SwipeBackResults | null;\n\n  browserSwipe: boolean;\n}\n\nclass ViewInfiniteComponent extends React.Component<\n  ViewInfiniteProps & DOMProps,\n  ViewInfiniteState\n> {\n  constructor(props: ViewInfiniteProps) {\n    super(props);\n\n    this.state = {\n      animated: false,\n\n      visiblePanels: [props.activePanel],\n      activePanel: props.activePanel,\n      isBack: undefined,\n      prevPanel: null,\n      nextPanel: null,\n\n      swipingBack: undefined,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n      swipeBackNextPanel: null,\n      swipeBackPrevPanel: null,\n      swipeBackResult: null,\n\n      browserSwipe: false,\n    };\n  }\n\n  static defaultProps: Partial<ViewInfiniteProps> = {\n    history: [],\n  };\n\n  private swipeBackPrevented = false;\n  private scrolls = scrollsCache[getNavId(this.props, warn) as string] || {};\n  private transitionFinishTimeout: ReturnType<typeof setTimeout> | undefined = undefined;\n  private animationFinishTimeout: ReturnType<typeof setTimeout> | undefined = undefined;\n\n  get document() {\n    return this.props.document;\n  }\n\n  get window() {\n    return this.props.window;\n  }\n\n  get panels() {\n    return React.Children.toArray(this.props.children) as React.ReactElement[];\n  }\n\n  panelNodes: { [id: string]: HTMLDivElement | null } = {};\n\n  componentWillUnmount() {\n    const id = getNavId(this.props);\n    if (id) {\n      scrollsCache[id] = this.scrolls;\n    }\n    if (this.animationFinishTimeout) {\n      clearTimeout(this.animationFinishTimeout);\n    }\n  }\n\n  componentDidUpdate(prevProps: ViewInfiniteProps, prevState: ViewInfiniteState) {\n    // Нужен переход\n    if (\n      prevProps.activePanel !== this.props.activePanel &&\n      !prevState.swipingBack &&\n      !prevState.browserSwipe\n    ) {\n      let isBack = false;\n\n      if (this.props.isBackCheck) {\n        isBack = this.props.isBackCheck({\n          from: prevProps.activePanel,\n          to: this.props.activePanel,\n        });\n      } else {\n        const firstLayerId = this.panels\n          .map((panel) => getNavId(panel.props, warn))\n          .find((id) => id === prevProps.activePanel || id === this.props.activePanel);\n        isBack = firstLayerId === this.props.activePanel;\n      }\n\n      this.blurActiveElement();\n\n      const prevScrolls = this.scrolls[prevProps.activePanel] || [];\n      const scrolls = {\n        ...this.scrolls,\n        [prevProps.activePanel]: [...prevScrolls, this.props.scroll?.getScroll().y],\n      };\n      this.scrolls = scrolls;\n\n      if (this.shouldDisableTransitionMotion()) {\n        this.flushTransition(prevProps.activePanel, isBack);\n      } else {\n        this.setState({\n          visiblePanels: [prevProps.activePanel, this.props.activePanel],\n          prevPanel: prevProps.activePanel,\n          nextPanel: this.props.activePanel,\n          activePanel: null,\n          animated: true,\n          isBack,\n        });\n\n        // Фолбек анимации перехода\n        if (!animationEvent.supported) {\n          if (this.animationFinishTimeout) {\n            clearTimeout(this.animationFinishTimeout);\n          }\n          this.animationFinishTimeout = setTimeout(\n            this.transitionEndHandler,\n            this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM\n              ? 300\n              : 600,\n          );\n        }\n      }\n    }\n\n    // Закончилась анимация свайпа назад\n    if (prevProps.activePanel !== this.props.activePanel && prevState.swipingBack) {\n      const nextPanel = this.state.swipeBackNextPanel;\n      const prevPanel = this.state.swipeBackPrevPanel;\n      let scrollPosition: undefined | number = undefined;\n\n      this.scrolls = {\n        ...this.scrolls,\n      };\n\n      if (prevPanel !== null) {\n        const prevPanelScrolls = [...(this.scrolls[prevPanel] || [])].slice(0, -1);\n        this.scrolls[prevPanel] = prevPanelScrolls;\n      }\n      if (nextPanel !== null) {\n        const newPanelScrolls = [...(this.scrolls[nextPanel] || [])];\n        scrollPosition = newPanelScrolls.pop();\n        this.scrolls[nextPanel] = newPanelScrolls;\n      }\n\n      this.setState(\n        {\n          swipeBackPrevPanel: null,\n          swipeBackNextPanel: null,\n          swipingBack: false,\n          swipeBackResult: null,\n          swipeBackStartX: 0,\n          swipeBackShift: 0,\n          activePanel: nextPanel,\n          visiblePanels: [nextPanel],\n        },\n        () => {\n          this.props.scroll?.scrollTo(0, scrollPosition);\n          prevProps.onTransition &&\n            prevProps.onTransition({\n              isBack: true,\n              from: prevPanel,\n              to: nextPanel,\n            });\n        },\n      );\n    }\n\n    // Началась анимация завершения свайпа назад.\n    if (!prevState.swipeBackResult && this.state.swipeBackResult) {\n      this.waitTransitionFinish(\n        this.pickPanel(this.state.swipeBackNextPanel),\n        this.swipingBackTransitionEndHandler,\n      );\n    }\n\n    // Если свайп назад отменился (когда пользователь недостаточно сильно свайпнул)\n    if (\n      prevState.swipeBackResult === SwipeBackResults.fail &&\n      !this.state.swipeBackResult &&\n      this.state.activePanel !== null\n    ) {\n      const newPanelScrolls = [...(this.scrolls[this.state.activePanel] || [])];\n      const scrollPosition = newPanelScrolls.pop();\n      this.scrolls = {\n        ...this.scrolls,\n        [this.state.activePanel]: newPanelScrolls,\n      };\n\n      this.props.scroll?.scrollTo(0, scrollPosition);\n    }\n\n    // Закончился Safari свайп\n    if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {\n      this.setState({\n        browserSwipe: false,\n        nextPanel: null,\n        prevPanel: null,\n        animated: false,\n        visiblePanels: [this.props.activePanel],\n        activePanel: this.props.activePanel,\n      });\n    }\n  }\n\n  shouldDisableTransitionMotion(): boolean {\n    return (\n      this.props.configProvider?.transitionMotionEnabled === false ||\n      !this.props.splitCol?.animate ||\n      this.props.platform === Platform.VKCOM\n    );\n  }\n\n  waitTransitionFinish(\n    elem: HTMLElement | null | undefined,\n    eventHandler: TransitionEventHandler,\n  ): void {\n    if (transitionEvent.supported && transitionEvent.name && elem) {\n      elem.removeEventListener(\n        transitionEvent.name as keyof HTMLElementEventMap,\n        eventHandler as EventListener,\n      );\n      elem.addEventListener(\n        transitionEvent.name as keyof HTMLElementEventMap,\n        eventHandler as EventListener,\n      );\n    } else {\n      if (this.transitionFinishTimeout) {\n        clearTimeout(this.transitionFinishTimeout);\n      }\n\n      this.transitionFinishTimeout = setTimeout(\n        eventHandler,\n        this.props.platform === Platform.ANDROID || this.props.platform === Platform.VKCOM\n          ? 300\n          : 600,\n      );\n    }\n  }\n\n  blurActiveElement(): void {\n    if (typeof this.window !== 'undefined' && this.document?.activeElement) {\n      (this.document.activeElement as HTMLElement).blur();\n    }\n  }\n\n  pickPanel(id: string | null) {\n    if (id === null) {\n      return undefined;\n    }\n    return this.panelNodes[id];\n  }\n\n  flushTransition(prevPanel: string, isBack: boolean) {\n    const activePanel = this.props.activePanel;\n\n    const prevPanelScrolls = [...(this.scrolls[prevPanel] || [])].slice(0, -1);\n    const newPanelScrolls = [...(this.scrolls[activePanel] || [])];\n    const scrollPosition = isBack ? newPanelScrolls.pop() : 0;\n    if (isBack) {\n      this.scrolls = {\n        ...this.scrolls,\n        [prevPanel]: prevPanelScrolls,\n        [activePanel]: newPanelScrolls,\n      };\n    }\n\n    this.setState(\n      {\n        prevPanel: null,\n        nextPanel: null,\n        visiblePanels: [activePanel],\n        activePanel: activePanel,\n        animated: false,\n        isBack,\n      },\n      () => {\n        this.props.scroll?.scrollTo(0, isBack ? scrollPosition : 0);\n        this.props.onTransition &&\n          this.props.onTransition({ isBack, from: prevPanel, to: activePanel });\n      },\n    );\n  }\n\n  transitionEndHandler = (e?: React.AnimationEvent): void => {\n    if (\n      (!e ||\n        [\n          styles['animation-ios-next-forward'],\n          styles['animation-ios-prev-back'],\n          styles['animation-view-next-forward'],\n          styles['animation-view-prev-back'],\n        ].includes(e.animationName)) &&\n      this.state.prevPanel !== null\n    ) {\n      this.flushTransition(this.state.prevPanel, Boolean(this.state.isBack));\n    }\n  };\n\n  swipingBackTransitionEndHandler = (e?: TransitionEvent): void => {\n    // indexOf because of vendor prefixes in old browsers\n    if (\n      !e ||\n      (e.propertyName.includes('transform') &&\n        e.target === this.pickPanel(this.state.swipeBackNextPanel))\n    ) {\n      switch (this.state.swipeBackResult) {\n        case SwipeBackResults.fail:\n          this.onSwipeBackCancel();\n          break;\n        case SwipeBackResults.success:\n          this.onSwipeBackSuccess();\n      }\n    }\n  };\n\n  onSwipeBackSuccess(): void {\n    this.props.onSwipeBack && this.props.onSwipeBack();\n  }\n\n  onSwipeBackCancel(): void {\n    this.props.onSwipeBackCancel && this.props.onSwipeBackCancel();\n    this.setState({\n      swipeBackPrevPanel: null,\n      swipeBackNextPanel: null,\n      swipingBack: false,\n      swipeBackResult: null,\n      swipeBackStartX: 0,\n      swipeBackShift: 0,\n    });\n  }\n\n  handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext = (event: TouchEvent) => {\n    if (this.state.browserSwipe) {\n      return;\n    }\n    const { swipeBackTriggered, viewportStartEdgeTouched, viewportEndEdgeTouched } =\n      getSwipeBackPredicates(event.startX, event.shiftX, this.window!.innerWidth);\n\n    if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {\n      this.setState({ browserSwipe: true });\n    }\n  };\n\n  handleTouchMoveXForIOSSwipeBackSimulation = (event: TouchEvent) => {\n    if (this.swipeBackPrevented || swipeBackExcluded(event)) {\n      return;\n    }\n\n    const { swipedToOpposite, swipeBackTriggered, viewportStartEdgeTouched } =\n      getSwipeBackPredicates(event.startX, event.shiftX, this.window!.innerWidth);\n\n    if (this.state.animated && swipeBackTriggered) {\n      return;\n    }\n\n    if (!this.state.swipingBack && this.props.history && this.props.history.length > 1) {\n      if (swipedToOpposite) {\n        this.swipeBackPrevented = true;\n        return;\n      }\n\n      if (!swipeBackTriggered) {\n        return;\n      }\n\n      if (\n        !viewportStartEdgeTouched &&\n        hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target as HTMLElement)\n      ) {\n        this.swipeBackPrevented = true;\n        return;\n      }\n      // Начался свайп назад\n      if (this.props.onSwipeBackStart) {\n        const payload = this.props.onSwipeBackStart(this.state.activePanel);\n        if (payload === 'prevent') {\n          this.swipeBackPrevented = true;\n          return;\n        }\n      }\n\n      if (this.state.activePanel !== null) {\n        // Note: вызываем закрытие клавиатуры. В iOS это нативное поведение при свайпе.\n        this.blurActiveElement();\n        const prevScrolls = this.scrolls[this.state.activePanel] || [];\n        this.scrolls = {\n          ...this.scrolls,\n          [this.state.activePanel]: [...prevScrolls, this.props.scroll?.getScroll().y],\n        };\n      }\n\n      this.setState({\n        swipingBack: true,\n        swipeBackStartX: event.startX,\n        swipeBackPrevPanel: this.state.activePanel,\n        swipeBackNextPanel: this.props.history.slice(-2)[0],\n      });\n    }\n\n    if (this.state.swipingBack) {\n      if (event.shiftX < 0) {\n        this.setState({ swipeBackShift: 0 });\n      } else if (event.shiftX > this.window!.innerWidth - this.state.swipeBackStartX) {\n        this.setState({ swipeBackShift: this.window!.innerWidth });\n      } else {\n        this.setState({ swipeBackShift: event.shiftX });\n      }\n    }\n  };\n\n  handleTouchEndForIOSSwipeBackSimulation = (event: TouchEvent) => {\n    this.swipeBackPrevented = false;\n\n    if (this.state.swipingBack && this.window) {\n      const speed = (this.state.swipeBackShift / event.duration) * 1000;\n      if (this.state.swipeBackShift === 0) {\n        this.onSwipeBackCancel();\n      } else if (this.state.swipeBackShift >= this.window.innerWidth) {\n        this.onSwipeBackSuccess();\n      } else if (speed > 250 || this.state.swipeBackShift >= this.window.innerWidth / 2) {\n        this.setState({ swipeBackResult: SwipeBackResults.success });\n      } else {\n        this.setState({ swipeBackResult: SwipeBackResults.fail });\n      }\n    }\n  };\n\n  calcPanelSwipeStyles(panelId: string | undefined): React.CSSProperties {\n    if (!canUseDOM || !this.window) {\n      return {};\n    }\n\n    const isPrev = panelId === this.state.swipeBackPrevPanel;\n    const isNext = panelId === this.state.swipeBackNextPanel;\n\n    if ((!isPrev && !isNext) || this.state.swipeBackResult) {\n      return {};\n    }\n\n    let prevPanelTranslate = `${this.state.swipeBackShift}px`;\n    let nextPanelTranslate = `${\n      -50 + (this.state.swipeBackShift * 100) / this.window.innerWidth / 2\n    }%`;\n    let prevPanelShadow =\n      (0.3 * (this.window.innerWidth - this.state.swipeBackShift)) / this.window.innerWidth;\n\n    if (this.state.swipeBackResult) {\n      return isPrev ? { boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})` } : {};\n    }\n\n    if (isNext) {\n      return {\n        transform: `translate3d(${nextPanelTranslate}, 0, 0)`,\n        WebkitTransform: `translate3d(${nextPanelTranslate}, 0, 0)`,\n      };\n    }\n    if (isPrev) {\n      return {\n        transform: `translate3d(${prevPanelTranslate}, 0, 0)`,\n        WebkitTransform: `translate3d(${prevPanelTranslate}, 0, 0)`,\n        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`,\n      };\n    }\n\n    return {};\n  }\n\n  render() {\n    const {\n      platform,\n      activePanel: _1,\n      splitCol,\n      configProvider,\n      history,\n      id,\n      nav,\n      onTransition,\n      onSwipeBack,\n      onSwipeBackStart,\n      onSwipeBackCancel,\n      window,\n      document,\n      scroll,\n      isBackCheck,\n      className,\n      ...restProps\n    } = this.props;\n    const {\n      prevPanel,\n      nextPanel,\n      activePanel,\n      isBack,\n      animated,\n      swipeBackPrevPanel,\n      swipeBackNextPanel,\n      swipeBackResult,\n      swipingBack,\n    } = this.state;\n\n    const panels = this.panels\n      .filter((panel) => {\n        const panelId = getNavId(panel.props, warn);\n\n        return (\n          (panelId !== undefined && this.state.visiblePanels.includes(panelId)) ||\n          panelId === swipeBackPrevPanel ||\n          panelId === swipeBackNextPanel\n        );\n      })\n      .sort((panel) => {\n        const panelId = getNavId(panel.props, warn);\n        const isPrevPanel = panelId === prevPanel || panelId === swipeBackPrevPanel;\n        const isNextPanel = panelId === nextPanel || panelId === swipeBackNextPanel;\n\n        if (isNextPanel) {\n          return swipingBack || this.state.isBack ? -1 : 1;\n        }\n\n        if (isPrevPanel) {\n          return swipingBack || this.state.isBack ? 1 : -1;\n        }\n\n        return 0;\n      });\n\n    const disableAnimation = this.shouldDisableTransitionMotion();\n    const iOSSwipeBackSimulationEnabled =\n      !disableAnimation &&\n      platform === Platform.IOS &&\n      configProvider?.isWebView &&\n      Boolean(onSwipeBack);\n\n    return (\n      <NavViewIdContext.Provider value={id || nav}>\n        <Touch\n          Component=\"section\"\n          {...restProps}\n          className={classNames(\n            styles['View'],\n            platform === Platform.IOS && classNames(styles['View--ios'], 'vkuiInternalView--ios'),\n            !disableAnimation && this.state.animated && styles['View--animated'],\n            !disableAnimation && this.state.swipingBack && styles['View--swiping-back'],\n            disableAnimation && styles['View--no-motion'],\n            className,\n          )}\n          onMoveX={\n            iOSSwipeBackSimulationEnabled\n              ? this.handleTouchMoveXForIOSSwipeBackSimulation\n              : platform === Platform.IOS\n              ? this.handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext\n              : undefined\n          }\n          onEnd={\n            iOSSwipeBackSimulationEnabled ? this.handleTouchEndForIOSSwipeBackSimulation : undefined\n          }\n        >\n          <div className={styles['View__panels']}>\n            {panels.map((panel: React.ReactElement) => {\n              const panelId = getNavId(panel.props, warn);\n              const isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;\n              const compensateScroll =\n                isPrev || panelId === swipeBackNextPanel || (panelId === nextPanel && isBack);\n              const isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);\n              const scrollList = (panelId && this.scrolls[panelId]) || [];\n              const scroll = scrollList[scrollList.length - 1] || 0;\n\n              return (\n                <div\n                  className={classNames(\n                    styles['View__panel'],\n                    panelId === activePanel && styles['View__panel--active'],\n                    panelId === prevPanel && styles['View__panel--prev'],\n                    panelId === nextPanel && styles['View__panel--next'],\n                    panelId === swipeBackPrevPanel && styles['View__panel--swipe-back-prev'],\n                    panelId === swipeBackNextPanel && styles['View__panel--swipe-back-next'],\n                    swipeBackResult === SwipeBackResults.success &&\n                      styles['View__panel--swipe-back-success'],\n                    swipeBackResult === SwipeBackResults.fail &&\n                      styles['View__panel--swipe-back-failed'],\n                  )}\n                  onAnimationEnd={isTransitionTarget ? this.transitionEndHandler : undefined}\n                  ref={(el) => panelId !== undefined && (this.panelNodes[panelId] = el)}\n                  style={this.calcPanelSwipeStyles(panelId)}\n                  key={panelId}\n                >\n                  <div\n                    className={styles['View__panel-in']}\n                    style={{ marginTop: compensateScroll ? -scroll : undefined }}\n                  >\n                    <NavTransitionDirectionProvider isBack={swipingBack || isBack}>\n                      <NavTransitionProvider\n                        entering={panelId === nextPanel || panelId === swipeBackNextPanel}\n                      >\n                        {panel}\n                      </NavTransitionProvider>\n                    </NavTransitionDirectionProvider>\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        </Touch>\n      </NavViewIdContext.Provider>\n    );\n  }\n}\n\nexport const ViewInfinite = withContext(\n  withContext(\n    withContext(\n      withPlatform(withDOM<ViewInfiniteProps>(ViewInfiniteComponent)),\n      SplitColContext,\n      'splitCol',\n    ),\n    ConfigProviderContext,\n    'configProvider',\n  ),\n  ScrollContext,\n  'scroll',\n);\n"]},"metadata":{},"sourceType":"module"}