{"ast":null,"code":"import { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _object_without_properties } from \"@swc/helpers/_/_object_without_properties\";\nimport { _ as _sliced_to_array } from \"@swc/helpers/_/_sliced_to_array\";\nimport * as React from \"react\";\nimport { classNames } from \"@vkontakte/vkjs\";\nimport { clamp } from \"../../helpers/math\";\nimport { useGlobalEventListener } from \"../../hooks/useGlobalEventListener\";\nimport { usePlatform } from \"../../hooks/usePlatform\";\nimport { usePrevious } from \"../../hooks/usePrevious\";\nimport { useTimeout } from \"../../hooks/useTimeout\";\nimport { useDOM } from \"../../lib/dom\";\nimport { Platform } from \"../../lib/platform\";\nimport { runTapticImpactOccurred } from \"../../lib/taptic\";\nimport { coordY } from \"../../lib/touch\";\nimport { useIsomorphicLayoutEffect } from \"../../lib/useIsomorphicLayoutEffect\";\nimport { useScroll } from \"../AppRoot/ScrollContext\";\nimport { FixedLayout } from \"../FixedLayout/FixedLayout\";\nimport { Touch } from \"../Touch/Touch\";\nimport TouchRootContext from \"../Touch/TouchContext\";\nimport { PullToRefreshSpinner } from \"./PullToRefreshSpinner\";\n\nfunction cancelEvent(event) {\n  if (!event) {\n    return false;\n  }\n\n  while (event.originalEvent) {\n    event = event.originalEvent;\n  }\n\n  if (event.preventDefault && event.cancelable) {\n    event.preventDefault();\n  }\n\n  if (event.stopPropagation) {\n    event.stopPropagation();\n  }\n\n  return false;\n}\n\nvar TOUCH_MOVE_EVENT_PARAMS = {\n  cancelable: true,\n  passive: false\n};\n/**\n * @see https://vkcom.github.io/VKUI/#/PullToRefresh\n */\n\nexport var PullToRefresh = function (_param) {\n  var children = _param.children,\n      isFetching = _param.isFetching,\n      onRefresh = _param.onRefresh,\n      className = _param.className,\n      restProps = _object_without_properties(_param, [\"children\", \"isFetching\", \"onRefresh\", \"className\"]);\n\n  var platform = usePlatform();\n  var scroll = useScroll();\n  var document = useDOM().document;\n  var prevIsFetching = usePrevious(isFetching);\n  var initParams = React.useMemo(function () {\n    return {\n      start: platform === Platform.IOS ? -10 : -45,\n      max: platform === Platform.IOS ? 50 : 80,\n      maxY: platform === Platform.IOS ? 400 : 80,\n      refreshing: platform === Platform.IOS ? 36 : 50,\n      positionMultiplier: platform === Platform.IOS ? 0.21 : 1\n    };\n  }, [platform]);\n\n  var _React_useState = _sliced_to_array(React.useState(initParams.start), 2),\n      spinnerY = _React_useState[0],\n      setSpinnerY = _React_useState[1];\n\n  var _React_useState1 = _sliced_to_array(React.useState(false), 2),\n      watching = _React_useState1[0],\n      setWatching = _React_useState1[1];\n\n  var _React_useState2 = _sliced_to_array(React.useState(false), 2),\n      refreshing = _React_useState2[0],\n      setRefreshing = _React_useState2[1];\n\n  var _React_useState3 = _sliced_to_array(React.useState(false), 2),\n      canRefresh = _React_useState3[0],\n      setCanRefresh = _React_useState3[1];\n\n  var _React_useState4 = _sliced_to_array(React.useState(false), 2),\n      touchDown = _React_useState4[0],\n      setTouchDown = _React_useState4[1];\n\n  var prevTouchDown = usePrevious(touchDown);\n  var touchY = React.useRef(0);\n\n  var _React_useState5 = _sliced_to_array(React.useState(0), 2),\n      contentShift = _React_useState5[0],\n      setContentShift = _React_useState5[1];\n\n  var _React_useState6 = _sliced_to_array(React.useState(0), 2),\n      spinnerProgress = _React_useState6[0],\n      setSpinnerProgress = _React_useState6[1];\n\n  var resetRefreshingState = React.useCallback(function () {\n    setWatching(false);\n    setCanRefresh(false);\n    setRefreshing(false);\n    setSpinnerY(initParams.start);\n    setSpinnerProgress(0);\n    setContentShift(0);\n  }, [initParams]);\n  var onRefreshingFinish = React.useCallback(function () {\n    if (!touchDown) {\n      resetRefreshingState();\n    }\n  }, [touchDown, resetRefreshingState]);\n\n  var _useTimeout = useTimeout(onRefreshingFinish, 1000),\n      setWaitFetchingTimeout = _useTimeout.set,\n      clearWaitFetchingTimeout = _useTimeout.clear;\n\n  useIsomorphicLayoutEffect(function () {\n    if (prevIsFetching !== undefined && prevIsFetching && !isFetching) {\n      onRefreshingFinish();\n    }\n  }, [prevIsFetching, isFetching, onRefreshingFinish]);\n  useIsomorphicLayoutEffect(function () {\n    if (prevIsFetching !== undefined && !prevIsFetching && isFetching) {\n      clearWaitFetchingTimeout();\n    }\n  }, [isFetching, prevIsFetching, clearWaitFetchingTimeout]);\n  var runRefreshing = React.useCallback(function () {\n    if (!refreshing && onRefresh) {\n      // cleanup if the consumer does not start fetching in 1s\n      setWaitFetchingTimeout();\n      setRefreshing(true);\n      setSpinnerY(function (prevSpinnerY) {\n        return platform === Platform.IOS ? prevSpinnerY : initParams.refreshing;\n      });\n      var runTapticImpactOccurredCalled = onRefresh(); // TODO [>=6]: удалить блок кода (#5049)\n\n      if (!runTapticImpactOccurredCalled) {\n        runTapticImpactOccurred(\"light\");\n      }\n    }\n  }, [refreshing, onRefresh, setWaitFetchingTimeout, platform, initParams.refreshing]);\n  useIsomorphicLayoutEffect(function () {\n    if (prevTouchDown !== undefined && prevTouchDown && !touchDown) {\n      if (!refreshing && canRefresh) {\n        runRefreshing();\n      } else if (refreshing && !isFetching) {\n        // only iOS can start refresh before gesture end\n        resetRefreshingState();\n      } else {\n        // refreshing && isFetching: refresh in progress\n        // OR !refreshing && !canRefresh: pull was not strong enough\n        setSpinnerY(refreshing ? initParams.refreshing : initParams.start);\n        setSpinnerProgress(0);\n        setContentShift(0);\n      }\n    }\n  }, [initParams, prevIsFetching, isFetching, onRefreshingFinish, prevTouchDown, touchDown, refreshing, canRefresh, runRefreshing]);\n  var startYRef = React.useRef(0);\n\n  var onTouchStart = function (e) {\n    if (refreshing) {\n      cancelEvent(e);\n    }\n\n    setTouchDown(true);\n    startYRef.current = e.startY;\n\n    if (document) {\n      // eslint-disable-next-line no-restricted-properties\n      document.documentElement.classList.add(\"vkui--disable-overscroll-behavior\");\n    }\n  };\n\n  var shouldPreventTouchMove = function (event) {\n    if (watching || refreshing) {\n      return true;\n    }\n    /* Нам нужно запретить touchmove у документа как только стало понятно, что\n    * начинается pull.\n    * состояния watching и refreshing устанавливаются слишком поздно и браузер\n    * может успеть начать нативный pull to refresh.\n    *\n    * Этот код является запасным вариантом, на случай, если css свойство\n    * overscroll-behavior не поддерживается\n    * */\n\n\n    var shiftY = coordY(event) - startYRef.current;\n    var pageYOffset = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;\n    var isRefreshGestureStarted = pageYOffset === 0 && shiftY > 0 && touchDown;\n    return isRefreshGestureStarted;\n  };\n\n  var onWindowTouchMove = function (event) {\n    if (shouldPreventTouchMove(event)) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  useGlobalEventListener(document, \"touchmove\", onWindowTouchMove, TOUCH_MOVE_EVENT_PARAMS);\n\n  var onTouchMove = function (e) {\n    var isY = e.isY,\n        shiftY = e.shiftY;\n    var start = initParams.start,\n        max = initParams.max;\n    var pageYOffset = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;\n\n    if (watching && touchDown) {\n      cancelEvent(e);\n      var positionMultiplier = initParams.positionMultiplier,\n          maxY = initParams.maxY;\n      var shift = Math.max(0, shiftY - touchY.current);\n      var currentY = clamp(start + shift * positionMultiplier, start, maxY);\n      var progress = currentY > -10 ? Math.abs((currentY + 10) / max) * 80 : 0;\n      setSpinnerY(currentY);\n      setSpinnerProgress(clamp(progress, 0, 80));\n      setCanRefresh(progress > 80);\n      setContentShift((currentY + 10) * 2.3);\n\n      if (progress > 85 && !refreshing && platform === Platform.IOS) {\n        runRefreshing();\n      }\n    } else if (isY && pageYOffset === 0 && shiftY > 0 && !refreshing && touchDown) {\n      cancelEvent(e);\n      touchY.current = shiftY;\n      setWatching(true);\n      setSpinnerY(start);\n      setSpinnerProgress(0);\n    }\n  };\n\n  var onTouchEnd = function () {\n    setWatching(false);\n    setTouchDown(false); // восстанавливаем overscroll behavior\n\n    if (document) {\n      // eslint-disable-next-line no-restricted-properties\n      document.documentElement.classList.remove(\"vkui--disable-overscroll-behavior\");\n    }\n  };\n\n  var spinnerTransform = \"translate3d(0, \".concat(spinnerY, \"px, 0)\");\n  var contentTransform = \"\";\n\n  if (platform === Platform.IOS && refreshing && !touchDown) {\n    contentTransform = \"translate3d(0, 100px, 0)\";\n  } else if (platform === Platform.IOS && (contentShift || refreshing)) {\n    contentTransform = \"translate3d(0, \".concat(contentShift, \"px, 0)\");\n  }\n\n  return /*#__PURE__*/React.createElement(TouchRootContext.Provider, {\n    value: true\n  }, /*#__PURE__*/React.createElement(Touch, _object_spread_props(_object_spread({}, restProps), {\n    onStart: onTouchStart,\n    onMove: onTouchMove,\n    onEnd: onTouchEnd,\n    className: classNames(\"vkuiPullToRefresh\", platform === Platform.IOS && \"vkuiPullToRefresh--ios\", watching && \"vkuiPullToRefresh--watching\", refreshing && \"vkuiPullToRefresh--refreshing\", className)\n  }), /*#__PURE__*/React.createElement(FixedLayout, {\n    className: \"vkuiPullToRefresh__controls\",\n    useParentWidth: true\n  }, /*#__PURE__*/React.createElement(PullToRefreshSpinner, {\n    style: {\n      transform: spinnerTransform,\n      WebkitTransform: spinnerTransform,\n      opacity: watching || refreshing || canRefresh ? 1 : 0\n    },\n    on: refreshing,\n    progress: refreshing ? undefined : spinnerProgress\n  })), /*#__PURE__*/React.createElement(\"div\", {\n    className: \"vkuiPullToRefresh__content\",\n    style: {\n      transform: contentTransform,\n      WebkitTransform: contentTransform\n    }\n  }, children)));\n};","map":{"version":3,"mappings":"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","names":["React","classNames","clamp","useGlobalEventListener","usePlatform","usePrevious","useTimeout","useDOM","Platform","runTapticImpactOccurred","coordY","useIsomorphicLayoutEffect","useScroll","FixedLayout","Touch","TouchRootContext","PullToRefreshSpinner","cancelEvent","event","originalEvent","preventDefault","cancelable","stopPropagation","TOUCH_MOVE_EVENT_PARAMS","passive","PullToRefresh","children","isFetching","onRefresh","className","restProps","platform","scroll","document","prevIsFetching","initParams","useMemo","start","IOS","max","maxY","refreshing","positionMultiplier","useState","spinnerY","setSpinnerY","watching","setWatching","setRefreshing","canRefresh","setCanRefresh","touchDown","setTouchDown","prevTouchDown","touchY","useRef","contentShift","setContentShift","spinnerProgress","setSpinnerProgress","resetRefreshingState","useCallback","onRefreshingFinish","set","setWaitFetchingTimeout","clear","clearWaitFetchingTimeout","undefined","runRefreshing","prevSpinnerY","runTapticImpactOccurredCalled","startYRef","onTouchStart","e","current","startY","documentElement","classList","add","shouldPreventTouchMove","shiftY","pageYOffset","getScroll","y","isRefreshGestureStarted","onWindowTouchMove","onTouchMove","isY","shift","Math","currentY","progress","abs","onTouchEnd","remove","spinnerTransform","concat","contentTransform","Provider","value","onStart","onMove","onEnd","useParentWidth","style","transform","WebkitTransform","opacity","on","div"],"sources":["C:\\Users\\kulag\\vk\\Ability\\node_modules\\@vkontakte\\vkui\\src\\components\\PullToRefresh\\PullToRefresh.tsx"],"sourcesContent":["import * as React from 'react';\nimport { classNames } from '@vkontakte/vkjs';\nimport { clamp } from '../../helpers/math';\nimport { useGlobalEventListener } from '../../hooks/useGlobalEventListener';\nimport { usePlatform } from '../../hooks/usePlatform';\nimport { usePrevious } from '../../hooks/usePrevious';\nimport { useTimeout } from '../../hooks/useTimeout';\nimport { DOMProps, useDOM } from '../../lib/dom';\nimport { Platform } from '../../lib/platform';\nimport { runTapticImpactOccurred } from '../../lib/taptic';\nimport { coordY, VKUITouchEvent } from '../../lib/touch';\nimport { useIsomorphicLayoutEffect } from '../../lib/useIsomorphicLayoutEffect';\nimport { AnyFunction, HasChildren } from '../../types';\nimport { ScrollContextInterface, useScroll } from '../AppRoot/ScrollContext';\nimport { FixedLayout } from '../FixedLayout/FixedLayout';\nimport { Touch, TouchEvent, TouchProps } from '../Touch/Touch';\nimport TouchRootContext from '../Touch/TouchContext';\nimport { PullToRefreshSpinner } from './PullToRefreshSpinner';\nimport styles from './PullToRefresh.module.css';\n\nfunction cancelEvent(event: any) {\n  if (!event) {\n    return false;\n  }\n  while (event.originalEvent) {\n    event = event.originalEvent;\n  }\n  if (event.preventDefault && event.cancelable) {\n    event.preventDefault();\n  }\n  if (event.stopPropagation) {\n    event.stopPropagation();\n  }\n  return false;\n}\n\nexport interface PullToRefreshProps extends DOMProps, TouchProps, HasChildren {\n  /**\n   * Будет вызвана для обновления контента (прим.: функция должна быть мемоизированным коллбэком)\n   *\n   * > ⚠️ **Для разработчиков VK Mini Apps**\n   * >\n   * > Сейчас метод под конец выполнения вызывает `runTapticImpactOccurred()`.\n   * >\n   * > В **v6** нужно будет самостоятельно вызывать эту функцию в вашем обработчике `onRefresh()`.\n   * > (см. https://github.com/VKCOM/VKUI/issues/5049). Функцию можете импортировать её из\n   * > бибилиотеки `@vkontakte/vk-bridge-react`.\n   * >\n   * > Чтобы подготовить ваше мини-приложение к обновлению до **v6**, в рамках **v5** вы уже можете\n   * > вызывать `runTapticImpactOccurred()`, но с одним условием: вы должны вернуть результат\n   * > выполнения функции, чтобы исключить двойной вызов. Результат функции — `boolean`. Если\n   * > вернётся `true`, значит, вызывать `runTapticImpactOccurred()` снова со стороны **VKUI** —\n   * > не нужно.\n   * >\n   * > ```jsx\n   * > const onRefresh = React.useCallback(() => {\n   * >  // ...\n   * >  return runTapticImpactOccurred();\n   * > }, []);\n   * >\n   * > // <PullToRefresh onRefresh={onRefresh} />\n   * > ```\n   * >\n   * > Соответственно, в **v6** ничего возвращать уже не потребуется.\n   */\n  onRefresh: AnyFunction;\n  /**\n   * Определяет, выполняется ли обновление. Для скрытия спиннера после получения контента необходимо передать `false`\n   */\n  isFetching?: boolean;\n  /** @ignore */\n  scroll?: ScrollContextInterface;\n}\n\nconst TOUCH_MOVE_EVENT_PARAMS = {\n  cancelable: true,\n  passive: false,\n};\n\n/**\n * @see https://vkcom.github.io/VKUI/#/PullToRefresh\n */\nexport const PullToRefresh = ({\n  children,\n  isFetching,\n  onRefresh,\n  className,\n  ...restProps\n}: PullToRefreshProps) => {\n  const platform = usePlatform();\n  const scroll = useScroll();\n  const { document } = useDOM();\n  const prevIsFetching = usePrevious(isFetching);\n\n  const initParams = React.useMemo(\n    () => ({\n      start: platform === Platform.IOS ? -10 : -45,\n      max: platform === Platform.IOS ? 50 : 80,\n      maxY: platform === Platform.IOS ? 400 : 80,\n      refreshing: platform === Platform.IOS ? 36 : 50,\n      positionMultiplier: platform === Platform.IOS ? 0.21 : 1,\n    }),\n    [platform],\n  );\n\n  const [spinnerY, setSpinnerY] = React.useState(initParams.start);\n  const [watching, setWatching] = React.useState(false);\n  const [refreshing, setRefreshing] = React.useState(false);\n  const [canRefresh, setCanRefresh] = React.useState(false);\n  const [touchDown, setTouchDown] = React.useState(false);\n  const prevTouchDown = usePrevious(touchDown);\n\n  const touchY = React.useRef(0);\n  const [contentShift, setContentShift] = React.useState(0);\n  const [spinnerProgress, setSpinnerProgress] = React.useState(0);\n\n  const resetRefreshingState = React.useCallback(() => {\n    setWatching(false);\n    setCanRefresh(false);\n    setRefreshing(false);\n    setSpinnerY(initParams.start);\n    setSpinnerProgress(0);\n    setContentShift(0);\n  }, [initParams]);\n\n  const onRefreshingFinish = React.useCallback(() => {\n    if (!touchDown) {\n      resetRefreshingState();\n    }\n  }, [touchDown, resetRefreshingState]);\n\n  const { set: setWaitFetchingTimeout, clear: clearWaitFetchingTimeout } = useTimeout(\n    onRefreshingFinish,\n    1000,\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    if (prevIsFetching !== undefined && prevIsFetching && !isFetching) {\n      onRefreshingFinish();\n    }\n  }, [prevIsFetching, isFetching, onRefreshingFinish]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (prevIsFetching !== undefined && !prevIsFetching && isFetching) {\n      clearWaitFetchingTimeout();\n    }\n  }, [isFetching, prevIsFetching, clearWaitFetchingTimeout]);\n\n  const runRefreshing = React.useCallback(() => {\n    if (!refreshing && onRefresh) {\n      // cleanup if the consumer does not start fetching in 1s\n      setWaitFetchingTimeout();\n\n      setRefreshing(true);\n      setSpinnerY((prevSpinnerY) =>\n        platform === Platform.IOS ? prevSpinnerY : initParams.refreshing,\n      );\n\n      const runTapticImpactOccurredCalled = onRefresh();\n      // TODO [>=6]: удалить блок кода (#5049)\n      if (!runTapticImpactOccurredCalled) {\n        runTapticImpactOccurred('light');\n      }\n    }\n  }, [refreshing, onRefresh, setWaitFetchingTimeout, platform, initParams.refreshing]);\n\n  useIsomorphicLayoutEffect(() => {\n    if (prevTouchDown !== undefined && prevTouchDown && !touchDown) {\n      if (!refreshing && canRefresh) {\n        runRefreshing();\n      } else if (refreshing && !isFetching) {\n        // only iOS can start refresh before gesture end\n        resetRefreshingState();\n      } else {\n        // refreshing && isFetching: refresh in progress\n        // OR !refreshing && !canRefresh: pull was not strong enough\n        setSpinnerY(refreshing ? initParams.refreshing : initParams.start);\n        setSpinnerProgress(0);\n        setContentShift(0);\n      }\n    }\n  }, [\n    initParams,\n    prevIsFetching,\n    isFetching,\n    onRefreshingFinish,\n    prevTouchDown,\n    touchDown,\n    refreshing,\n    canRefresh,\n    runRefreshing,\n  ]);\n\n  const startYRef = React.useRef(0);\n\n  const onTouchStart = (e: TouchEvent) => {\n    if (refreshing) {\n      cancelEvent(e);\n    }\n    setTouchDown(true);\n    startYRef.current = e.startY;\n\n    if (document) {\n      // eslint-disable-next-line no-restricted-properties\n      document.documentElement.classList.add('vkui--disable-overscroll-behavior');\n    }\n  };\n\n  const shouldPreventTouchMove = (event: VKUITouchEvent) => {\n    if (watching || refreshing) {\n      return true;\n    }\n\n    /* Нам нужно запретить touchmove у документа как только стало понятно, что\n     * начинается pull.\n     * состояния watching и refreshing устанавливаются слишком поздно и браузер\n     * может успеть начать нативный pull to refresh.\n     *\n     * Этот код является запасным вариантом, на случай, если css свойство\n     * overscroll-behavior не поддерживается\n     * */\n    const shiftY = coordY(event) - startYRef.current;\n    const pageYOffset = scroll?.getScroll().y;\n    const isRefreshGestureStarted = pageYOffset === 0 && shiftY > 0 && touchDown;\n    return isRefreshGestureStarted;\n  };\n\n  const onWindowTouchMove = (event: VKUITouchEvent) => {\n    if (shouldPreventTouchMove(event)) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  useGlobalEventListener(document, 'touchmove', onWindowTouchMove, TOUCH_MOVE_EVENT_PARAMS);\n\n  const onTouchMove = (e: TouchEvent) => {\n    const { isY, shiftY } = e;\n    const { start, max } = initParams;\n    const pageYOffset = scroll?.getScroll().y;\n\n    if (watching && touchDown) {\n      cancelEvent(e);\n\n      const { positionMultiplier, maxY } = initParams;\n\n      const shift = Math.max(0, shiftY - touchY.current);\n\n      const currentY = clamp(start + shift * positionMultiplier, start, maxY);\n      const progress = currentY > -10 ? Math.abs((currentY + 10) / max) * 80 : 0;\n\n      setSpinnerY(currentY);\n      setSpinnerProgress(clamp(progress, 0, 80));\n      setCanRefresh(progress > 80);\n      setContentShift((currentY + 10) * 2.3);\n\n      if (progress > 85 && !refreshing && platform === Platform.IOS) {\n        runRefreshing();\n      }\n    } else if (isY && pageYOffset === 0 && shiftY > 0 && !refreshing && touchDown) {\n      cancelEvent(e);\n\n      touchY.current = shiftY;\n      setWatching(true);\n      setSpinnerY(start);\n      setSpinnerProgress(0);\n    }\n  };\n\n  const onTouchEnd = () => {\n    setWatching(false);\n    setTouchDown(false);\n\n    // восстанавливаем overscroll behavior\n    if (document) {\n      // eslint-disable-next-line no-restricted-properties\n      document.documentElement.classList.remove('vkui--disable-overscroll-behavior');\n    }\n  };\n\n  const spinnerTransform = `translate3d(0, ${spinnerY}px, 0)`;\n  let contentTransform = '';\n\n  if (platform === Platform.IOS && refreshing && !touchDown) {\n    contentTransform = 'translate3d(0, 100px, 0)';\n  } else if (platform === Platform.IOS && (contentShift || refreshing)) {\n    contentTransform = `translate3d(0, ${contentShift}px, 0)`;\n  }\n\n  return (\n    <TouchRootContext.Provider value={true}>\n      <Touch\n        {...restProps}\n        onStart={onTouchStart}\n        onMove={onTouchMove}\n        onEnd={onTouchEnd}\n        className={classNames(\n          styles['PullToRefresh'],\n          platform === Platform.IOS && styles['PullToRefresh--ios'],\n          watching && styles['PullToRefresh--watching'],\n          refreshing && styles['PullToRefresh--refreshing'],\n          className,\n        )}\n      >\n        <FixedLayout className={styles['PullToRefresh__controls']} useParentWidth>\n          <PullToRefreshSpinner\n            style={{\n              transform: spinnerTransform,\n              WebkitTransform: spinnerTransform,\n              opacity: watching || refreshing || canRefresh ? 1 : 0,\n            }}\n            on={refreshing}\n            progress={refreshing ? undefined : spinnerProgress}\n          />\n        </FixedLayout>\n\n        <div\n          className={styles['PullToRefresh__content']}\n          style={{\n            transform: contentTransform,\n            WebkitTransform: contentTransform,\n          }}\n        >\n          {children}\n        </div>\n      </Touch>\n    </TouchRootContext.Provider>\n  );\n};\n"]},"metadata":{},"sourceType":"module"}