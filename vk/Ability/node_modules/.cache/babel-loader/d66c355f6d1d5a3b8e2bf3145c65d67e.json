{"ast":null,"code":"import { _ as _object_spread } from \"@swc/helpers/_/_object_spread\";\nimport { _ as _object_spread_props } from \"@swc/helpers/_/_object_spread_props\";\nimport { _ as _sliced_to_array } from \"@swc/helpers/_/_sliced_to_array\";\nimport * as React from \"react\";\nimport { rescale } from \"../../helpers/math\";\nexport var toPercent = function (v, min, max) {\n  return (v - min) / (max - min) * 100;\n};\nexport var offsetToValue = function (startX, width, min, max, step) {\n  return rescale(startX, [0, width], [min, max], {\n    step: step\n  });\n};\n\nvar restrictValueByMinMax = function (value, min, max) {\n  if (value < min) {\n    return min;\n  }\n\n  if (value > max) {\n    return max;\n  }\n\n  return value;\n};\n\nexport var updateInternalStateValue = function (prevValue, nextValue, min, max, dragging) {\n  var _prevValue = _sliced_to_array(prevValue, 2),\n      prevStartValue = _prevValue[0],\n      prevEndValue = _prevValue[1];\n\n  if (prevEndValue === null) {\n    return [restrictValueByMinMax(nextValue, min, max), null];\n  }\n\n  switch (dragging) {\n    case \"start\":\n      return nextValue > prevEndValue ? [prevEndValue, prevEndValue] : [restrictValueByMinMax(nextValue, min, max), prevEndValue];\n\n    case \"end\":\n      return nextValue < prevStartValue ? [prevStartValue, prevStartValue] : [prevStartValue, restrictValueByMinMax(nextValue, min, max)];\n\n    case null:\n    default:\n      return prevValue;\n  }\n};\nexport var updateInternalStateValueByNativeChange = function (prevValue, nextValue, dragging) {\n  var _prevValue = _sliced_to_array(prevValue, 2),\n      prevStartValue = _prevValue[0],\n      prevEndValue = _prevValue[1];\n\n  switch (dragging) {\n    case \"start\":\n      return [nextValue, prevEndValue];\n\n    case \"end\":\n      return [prevStartValue, nextValue];\n\n    case null:\n    default:\n      return prevValue;\n  }\n};\nexport function isMultipleValues(value) {\n  return value[1] !== null;\n}\nexport var snapDirection = function (prevValue, nextValue, type) {\n  if (type === \"start\") {\n    return \"start\";\n  }\n\n  if (type === \"end\") {\n    return \"end\";\n  }\n\n  var _prevValue = _sliced_to_array(prevValue, 2),\n      startRaw = _prevValue[0],\n      endRaw = _prevValue[1];\n  /* startRaw и endRaw могут быть равны, поэтому насильно добавляем разницу. */\n\n\n  var FORCE_DIFF_VALUE = 0.1;\n  var start = endRaw !== null ? startRaw - FORCE_DIFF_VALUE : startRaw;\n  var end = endRaw !== null ? endRaw + FORCE_DIFF_VALUE : 0;\n  return Math.abs(start - nextValue) <= Math.abs(end - nextValue) ? \"start\" : \"end\";\n};\nexport var getDraggingTypeByTargetDataset = function (target) {\n  if (target) {\n    if (target.dataset.type === \"start\") {\n      return \"start\";\n    }\n\n    if (target.dataset.type === \"end\") {\n      return \"end\";\n    }\n  }\n\n  return null;\n};\nvar resetProps = {\n  \"aria-label\": undefined,\n  \"aria-valuetext\": undefined,\n  \"aria-labelledby\": undefined\n};\nexport var extractSliderAriaAttributesFromRestProps = function (restProps) {\n  var ariaLabel = restProps[\"aria-label\"];\n  var ariaValueText = restProps[\"aria-valuetext\"];\n  var ariaLabelledBy = restProps[\"aria-labelledby\"];\n  return _object_spread_props(_object_spread({}, restProps, resetProps), {\n    ariaLabel: ariaLabel,\n    ariaValueText: ariaValueText,\n    ariaLabelledBy: ariaLabelledBy\n  });\n};","map":{"version":3,"mappings":";;;AAAA,YAAYA,KAAZ,MAAuB,OAAvB;AACA,SAASC,OAAT,QAAwB,oBAAxB;AAGA,OAAO,IAAMC,YAAY,UAACC,CAAD,EAAYC,GAAZ,EAAyBC,GAAzB,EAAyBA;SAAgB,CAAEF,IAAIC,GAAN,KAAcC,MAAMD,GAApB,IAA4B;CAAvF;AAEP,OAAO,IAAME,gBAAgB,UAC3BC,MAD2B,EAE3BC,KAF2B,EAG3BJ,GAH2B,EAI3BC,GAJ2B,EAK3BI,IAL2B,EAK3BA;EAEA,OAAOR,QAAQM,MAARN,EAAgB,CAAC,CAAD,EAAIO,KAAJ,CAAhBP,EAA4B,CAACG,GAAD,EAAMC,GAAN,CAA5BJ,EAAwC;IAAEQ;EAAF,CAAxCR,CAAP;AACF,CARO;;AAUP,IAAMS,wBAAwB,UAACC,KAAD,EAAgBP,GAAhB,EAA6BC,GAA7B,EAA6BA;EACzD,IAAIM,QAAQP,GAAZ,EAAiB;IACf,OAAOA,GAAP;EACF;;EACA,IAAIO,QAAQN,GAAZ,EAAiB;IACf,OAAOA,GAAP;EACF;;EACA,OAAOM,KAAP;AACF,CARA;;AAUA,OAAO,IAAMC,2BAA2B,UACtCC,SADsC,EAEtCC,SAFsC,EAGtCV,GAHsC,EAItCC,GAJsC,EAKtCU,QALsC,EAKtCA;EAEA,IAAuCF,2CAAvC;EAAA,IAAOG,iBAAgCH,aAAvC;EAAA,IAAuBI,eAAgBJ,aAAvC;;EAEA,IAAII,iBAAiB,IAArB,EAA2B;IACzB,OAAO,CAACP,sBAAsBI,SAAtBJ,EAAiCN,GAAjCM,EAAsCL,GAAtCK,CAAD,EAA6C,IAA7C,CAAP;EACF;;EAEA,QAAQK,QAAR;IACE,KAAK,OAAL;MACE,OAAOD,YAAYG,YAAZH,GACH,CAACG,YAAD,EAAeA,YAAf,CADGH,GAEH,CAACJ,sBAAsBI,SAAtBJ,EAAiCN,GAAjCM,EAAsCL,GAAtCK,CAAD,EAA6CO,YAA7C,CAFJ;;IAGF,KAAK,KAAL;MACE,OAAOH,YAAYE,cAAZF,GACH,CAACE,cAAD,EAAiBA,cAAjB,CADGF,GAEH,CAACE,cAAD,EAAiBN,sBAAsBI,SAAtBJ,EAAiCN,GAAjCM,EAAsCL,GAAtCK,CAAjB,CAFJ;;IAGF,KAAK,IAAL;IACA;MACE,OAAOG,SAAP;EAXJ;AAaF,CA1BO;AA4BP,OAAO,IAAMK,yCAAyC,UACpDL,SADoD,EAEpDC,SAFoD,EAGpDC,QAHoD,EAGpDA;EAEA,IAAuCF,2CAAvC;EAAA,IAAOG,iBAAgCH,aAAvC;EAAA,IAAuBI,eAAgBJ,aAAvC;;EACA,QAAQE,QAAR;IACE,KAAK,OAAL;MACE,OAAO,CAACD,SAAD,EAAYG,YAAZ,CAAP;;IACF,KAAK,KAAL;MACE,OAAO,CAACD,cAAD,EAAiBF,SAAjB,CAAP;;IACF,KAAK,IAAL;IACA;MACE,OAAOD,SAAP;EAPJ;AASF,CAfO;AAiBP,OAAO,SAASM,gBAAT,CAA0BR,KAA1B,EAAmD;EACxD,OAAOA,KAAK,CAAC,CAAD,CAALA,KAAa,IAApB;AACF;AAEA,OAAO,IAAMS,gBAAgB,UAC3BP,SAD2B,EAE3BC,SAF2B,EAG3BO,IAH2B,EAG3BA;EAEA,IAAIA,SAAS,OAAb,EAAsB;IACpB,OAAO,OAAP;EACF;;EACA,IAAIA,SAAS,KAAb,EAAoB;IAClB,OAAO,KAAP;EACF;;EAEA,IAA2BR,2CAA3B;EAAA,IAAOS,WAAoBT,aAA3B;EAAA,IAAiBU,SAAUV,aAA3B;EACA;;;EACA,IAAMW,mBAAmB,GAAzB;EACA,IAAMC,QAAQF,WAAW,IAAXA,GAAkBD,WAAWE,gBAA7BD,GAAgDD,QAA9D;EACA,IAAMI,MAAMH,WAAW,IAAXA,GAAkBA,SAASC,gBAA3BD,GAA8C,CAA1D;EACA,OAAOI,KAAKC,GAALD,CAASF,QAAQX,SAAjBa,KAA+BA,KAAKC,GAALD,CAASD,MAAMZ,SAAfa,CAA/BA,GAA2D,OAA3DA,GAAqE,KAA5E;AACF,CAlBO;AAoBP,OAAO,IAAME,iCAAiC,UAC5CC,MAD4C,EAC5CA;EAEA,IAAIA,MAAJ,EAAY;IACV,IAAIA,OAAOC,OAAPD,CAAeT,IAAfS,KAAwB,OAA5B,EAAqC;MACnC,OAAO,OAAP;IACF;;IACA,IAAIA,OAAOC,OAAPD,CAAeT,IAAfS,KAAwB,KAA5B,EAAmC;MACjC,OAAO,KAAP;IACF;EACF;;EACA,OAAO,IAAP;AACF,CAZO;AAcP,IAAME,aAAa;EACjB,cAAcC,SADG;EAEjB,kBAAkBA,SAFD;EAGjB,mBAAmBA;AAHF,CAAnB;AAMA,OAAO,IAAMC,2CAA2C,UACtDC,SADsD,EACtDA;EAEA,IAAMC,YAAYD,SAAS,CAAC,YAAD,CAA3B;EACA,IAAME,gBAAgBF,SAAS,CAAC,gBAAD,CAA/B;EACA,IAAMG,iBAAiBH,SAAS,CAAC,iBAAD,CAAhC;EACA,OAAOI,wCAAKJ,SAAL,EAAmBH,UAAnB,GAAmBA;IAAYI,oBAAZJ;IAAuBK,4BAAvBL;IAAsCM;EAAtCN,CAAnB,CAAP;AACF,CAPO","names":["React","rescale","toPercent","v","min","max","offsetToValue","startX","width","step","restrictValueByMinMax","value","updateInternalStateValue","prevValue","nextValue","dragging","prevStartValue","prevEndValue","updateInternalStateValueByNativeChange","isMultipleValues","snapDirection","type","startRaw","endRaw","FORCE_DIFF_VALUE","start","end","Math","abs","getDraggingTypeByTargetDataset","target","dataset","resetProps","undefined","extractSliderAriaAttributesFromRestProps","restProps","ariaLabel","ariaValueText","ariaLabelledBy","_object_spread_props"],"sources":["C:\\Users\\kulag\\vk\\Ability\\node_modules\\@vkontakte\\vkui\\src\\components\\Slider\\helpers.ts"],"sourcesContent":["import * as React from 'react';\nimport { rescale } from '../../helpers/math';\nimport type { InternalDraggingType, InternalValueState } from './types';\n\nexport const toPercent = (v: number, min: number, max: number) => ((v - min) / (max - min)) * 100;\n\nexport const offsetToValue = (\n  startX: number,\n  width: number,\n  min: number,\n  max: number,\n  step?: number,\n) => {\n  return rescale(startX, [0, width], [min, max], { step });\n};\n\nconst restrictValueByMinMax = (value: number, min: number, max: number) => {\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n};\n\nexport const updateInternalStateValue = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  min: number,\n  max: number,\n  dragging: InternalDraggingType | null,\n): InternalValueState => {\n  const [prevStartValue, prevEndValue] = prevValue;\n\n  if (prevEndValue === null) {\n    return [restrictValueByMinMax(nextValue, min, max), null];\n  }\n\n  switch (dragging) {\n    case 'start':\n      return nextValue > prevEndValue\n        ? [prevEndValue, prevEndValue]\n        : [restrictValueByMinMax(nextValue, min, max), prevEndValue];\n    case 'end':\n      return nextValue < prevStartValue\n        ? [prevStartValue, prevStartValue]\n        : [prevStartValue, restrictValueByMinMax(nextValue, min, max)];\n    case null:\n    default:\n      return prevValue;\n  }\n};\n\nexport const updateInternalStateValueByNativeChange = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  dragging: InternalDraggingType | null,\n): InternalValueState => {\n  const [prevStartValue, prevEndValue] = prevValue;\n  switch (dragging) {\n    case 'start':\n      return [nextValue, prevEndValue];\n    case 'end':\n      return [prevStartValue, nextValue];\n    case null:\n    default:\n      return prevValue;\n  }\n};\n\nexport function isMultipleValues(value: InternalValueState): value is [number, number] {\n  return value[1] !== null;\n}\n\nexport const snapDirection = (\n  prevValue: InternalValueState,\n  nextValue: number,\n  type: InternalDraggingType | null,\n) => {\n  if (type === 'start') {\n    return 'start';\n  }\n  if (type === 'end') {\n    return 'end';\n  }\n\n  const [startRaw, endRaw] = prevValue;\n  /* startRaw и endRaw могут быть равны, поэтому насильно добавляем разницу. */\n  const FORCE_DIFF_VALUE = 0.1;\n  const start = endRaw !== null ? startRaw - FORCE_DIFF_VALUE : startRaw;\n  const end = endRaw !== null ? endRaw + FORCE_DIFF_VALUE : 0;\n  return Math.abs(start - nextValue) <= Math.abs(end - nextValue) ? 'start' : 'end';\n};\n\nexport const getDraggingTypeByTargetDataset = <T extends (EventTarget & HTMLElement) | null>(\n  target: T,\n) => {\n  if (target) {\n    if (target.dataset.type === 'start') {\n      return 'start';\n    }\n    if (target.dataset.type === 'end') {\n      return 'end';\n    }\n  }\n  return null;\n};\n\nconst resetProps = {\n  'aria-label': undefined,\n  'aria-valuetext': undefined,\n  'aria-labelledby': undefined,\n};\n\nexport const extractSliderAriaAttributesFromRestProps = <T extends React.AriaAttributes>(\n  restProps: T,\n) => {\n  const ariaLabel = restProps['aria-label'];\n  const ariaValueText = restProps['aria-valuetext'];\n  const ariaLabelledBy = restProps['aria-labelledby'];\n  return { ...restProps, ...resetProps, ariaLabel, ariaValueText, ariaLabelledBy };\n};\n"]},"metadata":{},"sourceType":"module"}